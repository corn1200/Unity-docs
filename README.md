# Unity-docs

# 목차
* [1. 리지드바디](#1-리지드바디)

# 1. 리지드바디
## 개요
**리지드바디(Rigidbody)** 는 게임 오브젝트의 물리적 동작을 가능하게 하는 주요 컴포넌트다.    
리지드바디가 연결된 오브젝트는 중력에 즉시 반응한다.    
**Collider** 컴포넌트도 하나 이상 추가할 경우 게임 오브젝트가 당하는 충돌에 의해 움직인다.

Rigidbody 컴포넌트는 연결된 게임 오브젝트의 이동을 제어하므로 스크립트에서 포지션과 회전 같은 트랜스폼 프로퍼티를 변경하여 오브젝트를 이동하려고 하면 안된다.   
그 대신 **Forces**를 가하여 게임 오브젝트를 밀고 물리 엔진이 결과를 계산하도록 해야 한다.

경우에 따라 게임 오브젝트에 리지드바디를 연결하되, 물리 엔진으로 모션이 제어되는 것을 원치 않을 수 있다.    
예를 들어 스크립트 코드로 캐릭터를 직접 제어하면서도 캐릭터가 트리거(콜라이더의 트리거 참조)에 의해 감지될 수 있게 하고 싶을 때, 이렇게 스크립트로 생성되는 비물리적인 모션을 **키네마틱 모션**이라고 한다.     
Rigidbody 컴포넌트에는 **Is Kinematic**이라는 프로퍼티가 있다.      
이 프로퍼티는 물리 엔진의 제어 대상에서 컴포넌트를 제외하고, 스크립트에서 컴포넌트가 물리 힘의 영향을 받지 않고 움직이도록 하기 위해 사용할 수 있다.    
오브젝트에 대한 물리를 켜고 끌 수 있게 스크립트에서 **Is Kinematic** 값을 변경할 수 있지만, 성능 오버헤드가 발생하므로 신중하게 사용해야 한다.

## 프로퍼티
**Rigidbody**는 **GameObject**가 물리 제어로 동작하게 한다.     
리지드바디는 힘과 토크를 받아 오브젝트가 사실적으로 움직이도록 해준다.  
리지드바디가 포함된 모든 게임 오브젝트는 중력의 영향을 받아야 하며 스크립팅을 통해 가해진 힘으로 움직이거나 NVIDIA PhysX 물리 엔진을 통해 다른 오브젝트와 상호 작용해야 한다.

![리지드바디 프로퍼티](/img/rigidbody0.png)

|프로퍼티|기능|
|---|---|
|Mass|오브젝트의 질량(디폴트값은 킬로그램).|
|Drag|오브젝트가 힘에 의해 움직일 때 공기 저항이 영향을 미치는 정도를 나타낸다. 0이면 공기 저항이 없으며 무한대라면 오브젝트가 즉시 정지한다.|
|Angular Drag|오브젝트가 토크로 회전할 때 공기 저항이 영향을 미치는 정도를 나타낸다. 0이면 공기 저항이 없다. 앵글 드래그를 무한대로 설정한다고 해서 오브젝트의 회전이 멈추지는 않으니 주의해야 한다.|
|Use Gravity|활성화되면 오브젝트는 중력의 영향을 받는다.|
|Is Kinematic|활성화되면 오브젝트는 물리 엔진으로 제어되지 않고 오로지 **Transform**으로만 조작된다. 플랫폼을 옮기는 경우나 **HingeJoint**가 추가된 리지드바디를 애니메이션화하는 경우에 유용하다.|
|Interpolate|리지드바디의 움직임이 어색해 보일 경우 다음 옵션 중에서 하나를 시도해보아야 한다.|
|- None|보간이 적용되지 않는다.|
|- Interpolate|이전 프레임의 트랜스폼에 맞게 움직임을 부드럽게 처리한다.|
|- Extrapolate|다음 프레임의 트랜스폼을 추정해 움직임을 부드럽게 처리한다.|
|Collision Detection|빠르게 움직이는 오브젝트가 충돌의 감지 없이 다른 오브젝트를 지나쳐가는 것을 방지한다.|
|- Discrete|씬에서 다른 모든 콜라이더에 대해 불연속 충돌 검사를 사용한다. 다른 콜라이더는 충돌 테스트에 불연속 충돌 검사를 사용한다. 일반적인 충돌에 활용된다(기본값).|
|- Continuous|(리지드바디가 있는) 동적 콜라이더에 불연속 충돌 검사를, (리지드바디가 없는) 정적 콜라이더에 스위핑 기반 연속 충돌 검사를 사용한다. **Continuous Dynamic**으로 설정된 리지드바디는 이 리지드바디와의 충돌을 테스트할 때 연속 충돌 검사를 사용한다. 다른 리지드바디는 불연속 충돌 검사를 한다. Continuous Dynamic 검사로 충돌해야하는 오브젝트에 사용된다(물리 퍼포먼스에 큰 영향을 미치므로 빠른 오브젝트의 충돌 문제가 없다면 **Discrete**로 설정한다).|
|- Continuous Speculative|리지드바디와 콜라이더에 추측성 연속 충돌 검사를 사용한다. 키네마틱 바디를 설정할 수 있는 유일한 CCD 모드이다. 이 메서드는 스위핑 기반 연속 충돌 검사보다 리소스를 덜 소모한다.|
|Constraints|리지드바디의 움직임에 대한 제약 사항이다.|
|- Freeze Position|월드 좌표계의 X, Y, Z 축에서 이동하는 리지드바디를 선택적으로 중지 시킨다.|
|- Freeze Rotation|로컬 좌표계의 X, Y, Z 축에서 회전하는 리지드바디를 선택적으로 중지 시킨다.|

## 휴면
**리지드바디가 정의된 최소 선형 또는 회전 속도보다 느리게 이동하면 물리 엔진에서 정지했다고 간주된다**.     
그러면 게임 오브젝트가 충돌이나 힘을 받을 때까지 다시 이동하지 않으므로 **"휴면"** 모드로 설정된다.     
이 최적화는 리지드바디가 다음 번에 **"깨어날"** 때까지(즉, 움직임을 다시 시작할 때까지), 리지드바디를 업데이트하는 데 프로세서 시간이 사용되지 않는다.

대부분의 용도에서 Rigidbody 컴포넌트는 휴면 상태로 전환하고 깨우는 작업은 사용자가 인지하지 못하는 사이에 수행된다.     
하지만 **Transform** 포지션을 수정하여 (리지드바디가 없는)정적 콜라이더를 게임 오브젝트 안으로 이동하거나 오브젝트에서 멀리 이동할 경우 오브젝트가 깨어나지 않을 수 있다.   
이 경우 리지드바디 게임 오브젝트 아래의 바닥을 오브젝트 밖으로 이동하면 오브젝트가 공중에 매달릴 수 있다.   
이러한 경우에는 ``WakeUp`` 함수를 사용하여 게임 오브젝트를 명시적으로 깨울 수 있다.

## 콜라이더(Colliders)
콜라이더는 충돌이 일어나게 만들기 위해 리지드바디에 함께 추가해야 하는 또 다른 유형의 컴포넌트이다.     
두 개의 리지드바디가 서로 충돌하더라도 두 오브젝트 모두 콜라이더가 추가되어 있지 않으면 물리 엔진은 충돌을 연산하지 않는다.     
콜라이더가 없는 리지드바디는 물리 시뮬레이션 동안 서로를 지나쳐가기만 한다.

![리지드바디](/img/rigidbody1.png)
> 콜라이더는 리지드바디의 물리적 경계를 정의한다.

## 복합 콜라이더
***복합 콜라이더는 기본 콜라이더의 조합***으로, ***단일 리지드바디***처럼 함께 움직인다.    
정확하게 시뮬레이션하기에는 성능 측면에서 너무 복잡하거나 비용이 큰 모델을 가지고 있어 간단한 근사값을 사용해 최적의 방법으로 셰이프 충돌을 시뮬레이션할 때 유용하다.   
복합 콜라이더를 생성하기 위해서는 충돌 오브젝트의 자식 오브젝트를 만든 후 ***Collider*** 컴포넌트를 각각의 자식 오브젝트에 추가한다.  
이렇게 하면 각 콜라이더의 포지션, 회전, 스케일을 손쉽고 개별적으로 수행할 수 있다.  
자체적인 복합 콜라이더를 여러 기본 콜라이더 및 메시 콜라이더로 빌드할 수 있다.

![리지드바디](/img/rigidbody2.jpg)
> 실제 월드 복합 콜라이더 설정

위의 그림에서 총 모델의 게임 오브젝트에는 리지드바디가 추가되어 있고 여러 기본 콜라이더가 자식 게임 오브젝트로 있다.    
힘에 의해 ***부모 리지드바디***가 이동하면 ***자식 콜라이더***도 따라서 이동한다.   
부모 리지드바디는 자식 콜라이더가 다른 콜라이더와 씬에서 상호작용하는 방식을 기반으로 이동 방식을 변경한다.

## 연속 충돌 검사(Collision Detection)
***연속 충돌 검사는 빠르게 움직이는 콜라이더가 서로 통과하는 것을 방지하는 기능이다***.   
일반적인(***Discrete***) 충돌 검사를 사용할 때 이런 일이 발생할 수 있는데 한 프레임에서 오브젝트 하나가 콜라이더의 이쪽 편에 있고 다음 프레임에서 이미 콜라이더를 지나쳐버리는 것이다.    
빨리 움직이는 오브젝트의 리지드바디에서 연속 충돌 검사를 활성화하면 문제를 해결할 수 있다.  
충돌 검사 모드를 ***Continuous***로 설정해 리지드바디가 다른 정적 (즉, 리지드바디가 아닌)메시 콜라이더를 통과하지 않게 한다.     
***Continuous Dynamic***으로 설정해도 리지드바디가 ***Continuous*** 또는 ***Continuous Dynamic***으로 충돌 검사 모드가 설정된 리지드바디를 통과하지 않는다.     
***연속 충돌 검사는 박스-, 구체- 및 캡슐 콜라이더 용으로 지원된다***.     
연속 충돌 검사는 오브젝트가 서로 통과하는 경우에 ***충돌을 잡기 위한 안전망 역할***을 하나 ***물리적으로 정확한 충돌 결과를 내지는 않는다***.   
그러므로 빠르게 움직이는 오브젝트와 관련해 문제가 생기면 ***TimeManager*** 인스펙터의 고정 타임 스텝 값을 줄여 보다 정확한 시뮬레이션을 구현하는 방안을 고려할 수 있다.



















































<details>
<summary>이전 작성 목록</summary>

# 목차
* [1. 개요](#1-개요)
* [2. 개념](#2-개념)
    * [2.1. 게임 오브젝트](#21-게임-오브젝트)
    * [2.2. 컴포넌트](#22-컴포넌트)
    * [2.3. 씬](#23-씬)
    * [2.4. 에셋](#24-에셋)
    * [2.5. 스크립트](#25-스크립트)
    * [2.6. 물리 엔진](#26-물리-엔진)
    * [2.7. 네트워킹](#27-네트워킹)
* [3. 유니티 생명주기](#3-유니티-생명주기)
    * [3.1. Awake vs Start](#31-awake-vs-start)
    * [3.2. Update vs FixedUpdate vs LateUpdate](#32-update-vs-fixedupdate-vs-lateupdate)
* [4. C# & Unity](#4-c--unity)
    * [4.1. 박싱 & 언박싱](#41-박싱--언박싱)
    * [4.2. 직렬화 & 역직렬화](#42-직렬화--역직렬화)
    * [4.3. const vs readonly](#43-const-vs-readonly)
    * [4.4. string](#44-string)
    * [4.5. Garbage Collecto](#45-garbage-collector)
    * [4.6. delegate & event](#46-delegate--event)
    * [4.7. this](#47-this)
    * [4.8. List, Dictionary 등 자료구조의 내부](#48-list-dictionary-등-자료구조의-내부)
    * [4.9. C# vs C++](#49-c-vs-c)
* [5. 로컬 좌표 & 월드 좌표](#5-로컬-좌표--월드-좌표)
    * [5.1. 로컬 회전 & 월드 회전 ](#51-로컬-회전--월드-회전)
* [6. 센터 & 피벗](#6-센터--피벗)
* [7. 기즈모](#7-기즈모)
* [8. 회전](#8-회전)
* [9. 이동](#9-이동)
* [10. 리지드 바디](#10-리지드-바디)
    * [10.1. AddForce](#101-addforce)
    * [10.2. AddTorque](#102-addtorque)
* [11. 콜라이더](#11-콜라이더)
* [12. Lerp](#12-lerp)
* [13. 델타 타임](#13-델타-타임)
* [14. 렌더링 파이프라인](#14-렌더링-파이프라인)
    * [14.1. URP](#141-urp)
    * [14.2. HDRP](#142-hdrp)
    * [14.3. SRP](#143-srp)
* [15. 시네머신](#15-시네머신)
* [16. 코루틴 & 인보크](#16-코루틴--인보크)
    * [16.1. 코루틴 & 인보크 차이점](#161-코루틴--인보크-차이점)
    * [16.2. 코루틴 & Update](#162-코루틴--update)
* [17. 절차적 애니메이션](#17-절차적-애니메이션)
* [18. 오브젝트 풀링](#18-오브젝트-풀링)
* [19. 닷트윈](#19-닷트윈)

# 1. 개요
유니티 엔진은 게임 개발과 시뮬레이션을 위한 종합적인 크로스 플랫폼 게임 엔진이다.   
Unity Technologies에서 개발하고 유지 관리하며, 2005년에 처음 출시되었다.    
초기에는 주로 인디 게임 개발자들이 사용했지만, 시간이 흐르면서 많은 큰 회사와 AAA급 게임 제작에도 널리 사용되고 있다.

1. 크로스 플랫폼 지원: Unity는 Windows, macOS, Linux 등의 데스크톱 운영체제부터 iOS, Android, 콘솔 게임 기기, 웹 브라우저, VR/AR 디바이스까지 다양한 플랫폼을 지원한다.     
이러한 특성으로 한 번의 개발로 다양한 플랫폼으로 게임을 배포할 수 있다.
2. 사용자 친화적인 인터페이스: Unity는 쉽고 직관적인 사용자 인터페이스를 제공하여 개발자들이 쉽게 게임 개발에 참여할 수 있도록 돕는다.  
비전문가 개발자들에게도 접근하기 쉬운 툴을 제공하여 게임 제작의 기술적 장벽을 낮추는 데 도움이 된다.
3. 스크립트 언어: Unity는 주로 C# 스크립트를 사용하여 게임 로직을 구현한다.     
C#은 사용하기 쉽고 강력한 객체 지향 프로그래밍 언어로, 개발자들이 게임 오브젝트의 동작과 상호작용을 정의하는 데에 자주 활용된다.
4. 에셋과 에셋 스토어: Unity는 게임에 필요한 자원들을 "에셋"이라고 부른다.  
이러한 에셋들은 3D 모델, 텍스처, 애니메이션, 사운드, 스크립트 등으로 구성된다.  
Unity Asset Store를 통해 다른 개발자들이 제작한 에셋들을 구매하거나 판매할 수 있어, 개발 속도를 높이고 자원을 재활용할 수 있다.
5. 2D 및 3D 지원: Unity는 2D 및 3D 게임을 모두 지원한다.    
2D 게임 개발에 필요한 도구와 기능을 제공하며, 3D 게임 개발에서는 강력한 물리 시뮬레이션과 애니메이션 시스템을 사용할 수 있다.
6. 물리 엔진: Unity는 물리 엔진을 내장하고 있어, 게임 오브젝트들의 움직임과 충돌을 현실적으로 시뮬레이션할 수 있다.
7. 네트워킹 지원: Unity는 멀티플레이어 게임을 개발하기 위한 네트워킹 기능을 제공하여 여러 플레이어가 게임 세계를 함께 공유할 수 있도록 한다.

유니티 엔진은 이러한 특징과 개념을 통해 개발자들이 다양한 플랫폼에 게임을 빠르고 효율적으로 개발할 수 있도록 지원하며, 게임 개발의 접근성과 생산성을 높이는데 큰 역할을 한다.

# 2. 개념
유니티 엔진의 개념은 게임 개발과 시뮬레이션을 위한 기초적인 이해를 제공한다.    
다음은 유니티 엔진의 주요 개념에 대한 설명이다:

1. 게임 오브젝트(Game Objects): 유니티에서 모든 요소는 게임 오브젝트로 표현된다.    
게임 오브젝트는 캐릭터, 물체, 카메라, 조명 등 게임 월드의 모든 요소를 나타내는 기본 단위이다.   
각각의 게임 오브젝트는 위치, 회전, 크기 등을 가지고 있으며, 이들을 조작하여 게임 세계를 구성하고 상호작용을 만들어낸다.
2. 컴포넌트(Components): 게임 오브젝트는 기능을 갖는 다양한 컴포넌트들의 조합으로 이루어진다.   
예를 들어, 물리 엔진을 적용하려면 물리 컴포넌트를 추가하고, 움직임을 제어하려면 스크립트 컴포넌트를 추가한다.   
각 컴포넌트는 게임 오브젝트의 동작과 시각적 표현 등을 결정한다.
3. 씬(Scenes): 씬은 게임을 구성하는 하나의 환경 또는 레벨을 나타낸다.   
씬은 게임 오브젝트와 컴포넌트들의 계층 구조로 구성되며, 게임 플레이를 구성하는 모든 내용을 담고 있다.   
각 씬은 독립적으로 로드하거나 언로드할 수 있으므로, 다양한 레벨과 환경을 만들 수 있다.
4. 에셋(Assets): 유니티에서 사용되는 모든 자원들을 에셋이라고 한다.     
이러한 자원은 3D 모델, 텍스처, 사운드 파일, 애니메이션, 스크립트 등을 포함한다.     
에셋은 게임 개발에 필수적이며, Unity Asset Store에서는 개발자들이 다른 사용자들과 자원을 공유하고 구매할 수 있다.
5. 스크립트(Scripts): 유니티에서는 C#을 주로 사용하여 게임 오브젝트의 동작을 정의하는 스크립트를 작성한다.  
스크립트는 게임 오브젝트에 부착된 컴포넌트로, 게임 로직, 사용자 입력 처리, 인공지능, 특수 효과 등을 구현하는 데 사용된다.
6. 물리 시뮬레이션(Physics Simulation): 유니티는 물리 엔진을 내장하여 게임 오브젝트들이 중력, 충돌, 운동 등의 물리적 특성을 가질 수 있다.   
이를 통해 게임 월드의 현실성과 물리적 효과를 구현할 수 있다.
7. 네트워킹(Networking): 유니티는 멀티플레이어 게임을 개발하기 위한 네트워킹 기능을 지원한다.   
이를 통해 여러 플레이어가 동시에 게임 세계를 공유하고 상호작용할 수 있다.

# 2.1. 게임 오브젝트
유니티 엔진의 게임 오브젝트 작동 원리는 게임 오브젝트의 생성, 업데이트, 렌더링 등의 주요 단계로 이루어진다.     
각 게임 오브젝트는 개별적으로 동작하면서 게임 세계를 형성하고, 이들의 상호작용으로 게임이 진행된다.     
다음은 유니티 엔진 게임 오브젝트의 작동 원리를 단계별로 설명한다:

1. 생성(Creation): 게임 오브젝트는 유니티에서 씬(Scene)에 배치하거나 스크립트를 통해 동적으로 생성할 수 있다.   
오브젝트의 생성은 Instantiate() 함수를 호출하거나 에디터에서 오브젝트를 드래그 앤 드롭하여 이루어진다.  
각 게임 오브젝트는 고유한 이름과 초기 속성(위치, 회전, 크기)을 가지며, 트랜스폼(Transform) 컴포넌트를 통해 이러한 정보를 관리한다.
2. 업데이트(Update): 게임 오브젝트는 프레임 단위로 업데이트된다.    
이는 게임 오브젝트의 위치, 회전, 애니메이션, 물리 시뮬레이션 등이 매 프레임마다 변경될 수 있음을 의미한다.  
게임 오브젝트의 업데이트는 MonoBehaviour 스크립트 컴포넌트를 통해 이루어지며, 이 스크립트들은 유니티 엔진에서 지정된 순서대로 호출되어 실행된다.    
Update() 함수를 사용하여 프레임마다 실행되는 로직을 구현할 수 있다.
3. 렌더링(Rendering): 게임 오브젝트는 3D 렌더링 과정을 거쳐 화면에 표시된다.    
렌더링은 유니티 엔진의 그래픽 파이프라인을 통해 이루어지며, 게임 오브젝트의 3D 모델, 텍스처, 조명, 카메라 설정 등이 고려되어 화면에 출력된다.   
렌더링은 각 게임 오브젝트가 카메라에 따라 시점에 따라 보여지는 순서와 방식을 결정한다.
4. 상호작용(Interaction): 게임 오브젝트는 사용자와 상호작용하거나 다른 게임 오브젝트들과 상호작용할 수 있다.    
이를 구현하기 위해 개발자는 유니티의 콜라이더(Collider) 컴포넌트와 물리 시스템을 사용하여 충돌 검사를 하거나, 스크립트를 통해 사용자 입력에 따른 반응을 구현한다.
5. 파괴(Destruction): 게임 오브젝트는 더 이상 필요하지 않을 때 파괴될 수 있다.  
Destroy() 함수를 호출하거나 특정 조건을 만족할 때 게임 오브젝트를 파괴하는 로직을 작성한다.

이러한 단계들로 구성된 게임 오브젝트의 작동 원리는 유니티 엔진에서 게임 세계를 구현하고 제어하는 데에 중요한 역할을 한다.   

# 2.2. 컴포넌트
유니티 엔진의 컴포넌트(Component)는 게임 오브젝트의 기능을 정의하고 제어하는 데 사용되는 모듈화된 요소이다.     
각각의 게임 오브젝트는 여러 개의 컴포넌트들을 가질 수 있으며, 이들 컴포넌트들은 게임 오브젝트의 동작과 시각적 표현, 상호작용 등을 결정한다.     
컴포넌트의 작동 원리를 설명하려면 아래의 주요 포인트들을 고려해야 한다:

1. 컴포넌트의 추가: 유니티에서 컴포넌트는 에디터를 통해 게임 오브젝트에 추가할 수 있다.     
에디터에서 오브젝트를 선택하고, 컴포넌트를 추가하고자 하는 컴포넌트 목록에서 선택하면 된다.     
또한 스크립트로 컴포넌트를 동적으로 추가하는 것도 가능하다.
2. 컴포넌트의 초기화: 컴포넌트가 게임 오브젝트에 추가되면, Awake()와 Start()와 같은 초기화 함수들이 호출된다.   
이 함수들은 컴포넌트의 상태를 초기화하거나, 다른 컴포넌트나 게임 오브젝트와의 연결을 설정하는 등의 작업을 수행한다.
3. 제어와 행위 분리: 컴포넌트 기반 설계의 장점은 제어와 행위를 분리할 수 있다는 점이다.     
즉, 각 컴포넌트는 독립적으로 작동하며, 필요에 따라 추가/제거/교체가 가능하다.   
이로 인해 코드의 재사용성이 증가하고 개발자들은 높은 수준의 모듈화를 이뤄낼 수 있다.
4. 컴포넌트 간 통신: 컴포넌트들은 서로간에 통신을 할 수 있으며, 이를 통해 게임 오브젝트의 동작을 복잡하게 조합하고 상호작용할 수 있다.  
이는 개발자들이 유연하고 다양한 게임 플레이 시나리오를 구현할 수 있도록 돕는다.

유니티 엔진에서 컴포넌트의 작동 원리는 게임 개발의 핵심 원리 중 하나로, 각 컴포넌트들이 조합되어 게임의 동작과 시각적인 표현, 상호작용을 결정한다.  

# 2.3. 씬
유니티 엔진의 씬(Scene)은 게임 세계를 구성하는 하나의 환경 또는 레벨을 나타내며, 게임 오브젝트들과 다른 리소스들을 담고 있는 컨테이너이다.  
씬은 게임을 구성하는 기본 단위로서, 각각의 씬은 독립적으로 로드하거나 언로드할 수 있다.     
이를 통해 다양한 레벨과 환경을 만들고 게임 흐름을 관리할 수 있다.   
유니티 엔진에서 씬의 작동 원리는 아래와 같은 순서로 진행된다:

1. 씬의 생성 및 로드: 씬은 유니티 프로젝트에 생성되고 저장된다.     
유니티 에디터를 통해 새로운 씬을 생성하거나 기존의 씬을 로드할 수 있다.     
또는 게임 실행 중에 동적으로 씬을 로드할 수도 있다.
2. 게임 오브젝트 배치: 씬은 게임 오브젝트들을 배치하는 공간이다.    
에디터를 사용하여 게임 오브젝트들을 씬에 배치하거나 스크립트를 통해 동적으로 생성할 수 있다.    
게임 오브젝트는 씬의 내용을 구성하는 주요 요소이며, 각각의 게임 오브젝트는 해당하는 컴포넌트들을 가지고 있다.
3. 컴포넌트 초기화: 씬에 배치된 각 게임 오브젝트의 컴포넌트들은 Awake() 함수를 통해 초기화된다.     
이 함수는 컴포넌트가 생성될 때 한 번만 호출되며, 컴포넌트의 상태를 초기화하거나 다른 컴포넌트나 오브젝트와의 연결을 설정하는 등의 작업을 수행한다.
4. 씬 전환: 유니티 엔진은 여러 개의 씬을 로드하고 전환할 수 있다.   
특정 이벤트에 따라 다른 씬으로 전환하거나, 다른 씬을 동적으로 로드하여 게임 흐름을 제어할 수 있다.
5. 씬의 저장과 언로드: 에디터에서 작업한 씬은 프로젝트에 저장되며, 게임 실행 중에는 불필요한 씬을 언로드하여 메모리 관리에 유리하게 한다.

이러한 과정을 거쳐 유니티 엔진의 씬은 게임 개발에서 중요한 역할을 한다.     
씬을 잘 구성하고 관리하면 게임의 흐름과 세계를 효과적으로 제어하고 구현할 수 있다.

# 2.4. 에셋
유니티 엔진 에셋(Assets)은 게임 개발에 사용되는 모든 자원들을 말한다.   
이는 3D 모델, 텍스처, 사운드 파일, 애니메이션, 스크립트 등 다양한 유형의 자원들을 포함한다.     
에셋은 게임 오브젝트에 부착된 컴포넌트처럼 동작하지 않으며, 게임 세계의 구성과 기능을 결정하는 것보다는 게임 개발의 재료로 사용된다.    
유니티 엔진의 에셋은 다음과 같은 작동 원리로 동작한다:

1. 에셋의 생성과 가져오기: 유니티 프로젝트 내에서 새로운 에셋을 생성하거나 기존의 에셋을 가져올 수 있다.    
에셋을 프로젝트 내 적절한 폴더에 추가하고 구성한다.
2. 에셋의 인스턴스화: 에셋을 프로젝트에서 씬으로 끌어와서 사용하면, 씬에 에셋의 인스턴스가 생성된다.    
이 인스턴스는 씬에 속한 개별적인 오브젝트로서 동작하며, 기존 에셋의 변경에 영향을 받지 않는다.
3. 에셋의 연결과 참조: 에셋은 게임 오브젝트의 컴포넌트에 연결되거나 스크립트에서 참조될 수 있다.    
예를 들어, 3D 모델 에셋은 게임 오브젝트에 Mesh Renderer 컴포넌트로 연결되어 시각적인 모습을 결정하거나, 스크립트에서 로드되어 특정 동작을 수행할 수 있다.
4. 에셋의 빌드: 게임을 빌드할 때, 프로젝트의 에셋들은 최적화 및 압축 등의 처리를 거쳐 게임 패키지로 포함된다.   
이는 게임이 실행될 때 자원을 효율적으로 사용할 수 있도록 한다.
5. 에셋 번들: 에셋 번들은 게임을 런타임에서 동적으로 로드하는 데에 사용되는 패키지이다.     
게임에 필요한 에셋들을 번들로 묶어서 원격으로 다운로드하거나 게임 실행 중에 로드하여 효율적인 에셋 관리를 가능하게 한다.

유니티 엔진의 에셋은 게임 개발 과정에서 매우 중요한 요소로 작동한다.    
잘 구성된 에셋은 게임의 품질과 성능을 향상시키고, 개발 시간을 단축하며, 개발자들이 공동으로 작업하고 에셋을 공유하는 데에도 도움을 준다.

# 2.5. 스크립트
유니티 엔진에서 스크립트(Script)는 게임 오브젝트의 동작과 상호작용, 게임 로직 등을 정의하고 구현하는 데 사용된다.   
스크립트는 주로 C# 언어를 사용하여 작성되며, 개발자들은 스크립트를 통해 게임 오브젝트의 행동을 제어하고 게임의 동작을 구현한다.     
스크립트의 작동 원리는 아래와 같은 순서로 이루어진다.

1. 스크립트의 생성과 추가: 개발자는 유니티 프로젝트 내에서 새로운 스크립트를 생성하거나 기존의 스크립트를 가져와서 사용할 수 있다.  
스크립트는 에디터를 통해 게임 오브젝트에 추가되어 동작하게 된다.
2. 스크립트의 구현: 스크립트는 C# 언어를 사용하여 구현된다.     
개발자들은 해당 스크립트 파일을 에디터나 외부 코드 편집기에서 열어서 로직과 기능을 작성한다.    
스크립트는 MonoBehaviour 클래스를 상속받아 유니티 엔진과 상호작용할 수 있다.
3. 스크립트의 컴포넌트로서의 동작: 스크립트는 게임 오브젝트에 컴포넌트로 추가되어 동작한다.     
MonoBehaviour 클래스를 상속받았기 때문에, 스크립트는 해당 게임 오브젝트의 컴포넌트로서 업데이트 함수(Update(), FixedUpdate(), LateUpdate())를 갖게 되어 프레임마다 동작을 처리할 수 있다.
4. 게임 오브젝트와의 상호작용: 스크립트는 게임 오브젝트와 상호작용하여 게임의 동작을 제어한다.  
스크립트는 게임 오브젝트의 트랜스폼(Transform)을 변경하여 위치, 회전, 크기 등을 조정하거나, 다른 컴포넌트들과 상호작용하여 게임 오브젝트의 동작을 결정한다.
5. 사용자 입력 처리: 스크립트는 사용자의 입력을 처리하여 게임 오브젝트의 동작을 변화시킬 수 있다.   
마우스 클릭, 키보드 입력 등을 감지하고 이를 처리하여 게임의 플레이어 상호작용을 구현한다.
6. 상태 및 변수 관리: 스크립트는 변수를 사용하여 게임 오브젝트의 상태와 속성을 저장하고 관리한다.   
변수는 스크립트의 필드로 선언되며, 게임의 진행과 상호작용에 따라 값이 변경될 수 있다.
7. 이벤트 처리: 스크립트는 이벤트를 사용하여 특정 조건이 발생했을 때 특정 동작을 수행할 수 있다.    
예를 들어 충돌이 발생했을 때, 타이머가 만료되었을 때 등의 이벤트를 처리할 수 있다.

유니티 엔진의 스크립트는 게임 개발에서 중요한 역할을 수행하며, 게임의 동작을 제어하고 구현하는 데에 큰 영향을 미친다.

# 2.6. 물리 엔진
유니티의 물리 엔진은 게임 세계에서 물리적인 동작을 시뮬레이션하고 게임 오브젝트들 간의 상호작용을 처리하는 역할을 담당한다.     
물리 엔진은 게임 오브젝트의 움직임, 충돌, 중력 등과 같은 물리적인 요소들을 모사하여 현실적인 동작을 제공한다.   
이를 통해 게임에서 물체들이 자연스럽게 움직이고 상호작용하도록 구현할 수 있다.

유니티의 물리 엔진은 주로 NVIDIA의 PhysX 물리 엔진을 기반으로 작동한다.     
다음은 유니티의 물리 엔진 작동 원리에 대한 간단한 설명이다:

1. 물리 업데이트 주기: 유니티의 물리 엔진은 일정한 시간 간격으로 물리적인 시뮬레이션을 실행한다.    
이를 물리 업데이트 주기(Physics Update Rate)라고 한다.  
기본적으로 프레임 속도(Fixed Timestamp)에 따라 물리 업데이트 주기가 결정되지만, 개발자들은 설정을 조정하여 원하는 물리 업데이트 주기를 지정할 수도 있다.
2. 충돌 검사: 물리 엔진은 각 게임 오브젝트의 콜라이더(Collider) 컴포넌트를 통해 충돌 검사를 수행한다.   
충돌 검사는 물체들 간의 겹침 여부를 확인하여 충돌이 발생했는지 감지한다.
3. 물리 시뮬레이션: 충돌이 발생하면 물리 엔진은 해당 게임 오브젝트의 질량, 속력, 힘 등 물리적인 특성을 고려하여 물체의 움직임을 시뮬레이션한다.     
이러한 시뮬레이션은 게임 오브젝트에 부착된 리지드바디(Rigidbody) 컴포넌트를 통해 제어된다.
4. 중력 적용: 물리 엔진은 중력을 모방하여 물체들에게 아래 방향으로 힘을 가한다.     
이로 인해 물체들이 떨어지는 동작을 구현할 수 있다.
5. 물체 상호작용: 물리 엔진은 물체들 간의 상호작용을 처리한다.  
충돌한 물체들이 서로에게 힘을 가하고, 관성에 따라 움직임이 전달되는 등의 상호작용이 이루어진다.
6. 물리 엔진 레이어: 물리 엔진은 물리적인 계산을 레이어별로 관리한다.   
이를 통해 어떤 물체들은 충돌하지 않거나, 충돌이 무시되어야 하는 경우를 설정할 수 있다.

유니티의 물리 엔진은 게임 오브젝트들이 현실적인 물리적 동작을 수행하도록 돕는다.

# 2.7. 네트워킹
유니티 엔진은 네트워킹(Networking)을 통해 다중 플레이어 게임을 구현할 수 있는 기능을 제공한다.  
네트워킹은 여러 플레이어가 동시에 게임 세계에 접속하여 상호작용할 수 있도록 해주는 기술로, 멀티플레이어 게임을 가능하게 한다.   
유니티 엔진의 네트워킹 작동 원리는 아래와 같은 단계로 이루어진다:

1. 네트워크 설정: 먼저, 개발자는 프로젝트의 네트워크 설정을 구성해야 한다.  
유니티 에디터에서 플레이어 수, 호스트와 클라이언트 설정, 서버 접속 등의 네트워크 옵션을 설정한다.
2. 네트워크 컴포넌트 추가: 각각의 게임 오브젝트는 네트워크 컴포넌트를 추가해야 한다.    
네트워크 컴포넌트는 게임 오브젝트를 네트워크로 동기화하여 다른 플레이어들과 동일한 사앹를 유지할 수 있게 한다.
3. 네트워크 식별자 설정: 각 게임 오브젝트는 고유한 네트워크 식별자를 가져야 한다.   
이 식별자는 게임 오브젝트가 네트워크에서 구분되는 역할을 한다.  
일반적으로 네트워크 식별자는 네트워크 뷰(NetworkView) 컴포넌트를 통해 설정된다.
4. 호스트 및 클라이언트 접속: 게임 플레이어들은 호스트 또는 클라이언트로 게임에 접속한다.   
호스트는 게임 세계를 호스팅하고, 클라이언트는 호스트와 연결하여 게임에 참여한다.
5. 데이터 동기화: 네트워크로 연결된 게임 플레이어들은 네트워크 컴포넌트를 통해 게임 오브젝트의 상태를 주기적으로 동기화한다.    
이로 인해 모든 플레이어들은 동일한 게임 세계를 볼 수 있게 된다.
6. RPC(Remote Procedure Call): RPC는 네트워크 플레이어들 간에 함수를 호출하는 기능을 제공한다.  
네트워크 상에서 함수를 호출하여 게임 오브젝트들 간에 상호작용을 구현할 수 있다.
7. 랭킹 및 매칭: 네트워킹은 랭킹 시스템과 매칭 시스템을 구현하는 데에도 사용된다.   
이를 통해 플레이어들끼리 경쟁하고, 적절한 상대와 매칭되어 게임을 즐길 수 있다.

이러한 네트워킹 기능을 통해 유니티 엔진은 다중 플레이어 게임을 구현할 수 있게 되며, 인터넷을 통해 플레이어들이 함께 플레이하거나 경쟁할 수 있도록 지원한다.

# 3. 유니티 생명주기
유니티 엔진은 다양한 생명주기(Lifecycle) 단계를 가지고 있으며, 이러한 단계들은 게임 오브젝트와 스크립트 등이 어떻게 동작하는지를 관리하고 제어하는 데에 사용된다.   
유니티 엔진의 주요 생명주기 단계는 다음과 같다:

1. 초기화(Initialization):  
    * Awake(): 게임 오브젝트가 생성되면 가장 먼저 Awake() 함수가 호출된다.  
    이 단계에서는 컴포넌트의 초기화를 수행한다.     
    즉, 변수를 설정하거나 다른 컴포넌트와의 연결을 설정하는 등의 작업이 이루어진다.
2. 활성화(Active):
    * OnEnable(): Awake() 함수가 호출된 다음에 OnEnable() 함수가 호출된다.  
    이 단계에서는 게임 오브젝트가 활성화되었을 때 필요한 초기화를 수행한다.     
    보통 이 단계에서 이벤트 리스너 등을 등록한다.
3. 업데이트(Update):
    * Update(): 게임 오브젝트가 활성화된 동안에는 프레임마다 Update() 함수가 호출된다.  
    이 단계에서는 게임 오브젝트의 상태를 업데이트하고 게임 로직을 실행한다.
4. 물리 업데이트(Physics Update):
    * FixedUpdate(): 프레임 속도(Fixed Timestep)에 따라 물리 엔진 업데이트 주기에 맞추어 FixedUpdate() 함수가 호출된다.     
    이 단계에서는 물리 연산을 처리한다.     
    물리적인 움직임과 상호작용은 이 단계에서 다룬다.
5. 렌더링(Rendering):
    * LateUpdate(): 모든 업데이트가 끝난 후 LateUpdate() 함수가 호출된다.   
    이 단계에서는 주로 카메라의 움직임이나 다른 오브젝트들의 위치 조정 등을 수행한다.   
    이렇게 함으로써 업데이트 이후에 다른 오브젝트들의 상태를 바탕으로 움직임을 조정할 수 있다.
6. 비활성화(Inactive):
    * OnDisable(): 게임 오브젝트가 비활성화되거나 더 이상 사용되지 않을 때 OnDisable() 함수가 호출된다.     
    이 단계에서는 활성화 시에 등록한 이벤트 리스너 등을 해제한다.
7. 제거(Destroy):
    * OnDestroy(): 게임 오브젝트가 제거될 때 OnDestroy() 함수가 호출된다.   
    이 단계에서는 필요한 정리 작업을 수행한다.

이러한 생명주기 단계들을 이해하고 활용하면 게임 오브젝트와 스크립트의 동작을 더욱 효율적으로 제어하고 관리할 수 있다.   
게임 오브젝트와 스크립트의 생명주기를 올바르게 다루면 메모리 누수나 예상치 못한 동작 등을 방지할 수 있다.

![유니티 생명주기](/img/monobehaviour_flowchart.svg)

# 3.1. Awake vs Start
둘 다 클래스의 초기화에 사용되는 이벤트 함수로 호출 시기에 따른 차이가 있다.

* Awake
    * 스크립트와 연결된 게임 오브젝트가 인스턴스화 되거나 스크립트가 처음 로드될 때 호출된다
    * 해당 오브젝트가 Enable 상태가 아니라고 해도 위 조건에 따라 로드되면 호출된다
    * 다른 오브젝트에 대한 참조를 생성할 때 주로 사용하게 된다
        * 단 Awake 호출은 무작위
        * 무작위성으로 인해 다른 스크립트의 참조를 통해 접근하면 NullReferenceException 이 발생하게 된다
* Start
    * 해당 스크립트 컴포넌트가 활성화 되는 순간 호출된다
    * 호출 시기는 Awake 보다는 느리게 첫 Update보다는 빠르게 호출된다
    * Start에서는 참조를 통해 접근하는 작업이 가능하다

### OnEnable vs Start
둘 다 '컴포넌트가 활성화 될 때' 불린다는 공통점이 있어 묶이게 되지만 Start는 한 번, OnEnable은 활성화 될 때 마다 불리게 된다는 차이점이 있다.   
때문에 초기화 작업에 OnEnable을 활용하면 안된다.    
OnEnable은 주로 오브젝트 풀링에 사용하게 되는 함수라고 볼 수 있다.

# 3.2. Update vs FixedUpdate vs LateUpdate
* Update: 프레임 단위로 호출됨
* LateUpdate: Update 호출 뒤 호출됨
* FixedUpdate: 고정 단위로 호출됨

FixedUpdate의 '고정 단위'는 물리 엔진에 의해 결정 되어 컴퓨터 성능에 따라 프레임이 다르게 나와 호출 간격이 일정하지 않은 Update와는 달리 일정하게 불리게 된다.   
이런 이유로 인해서 Rigidbody를 조작할 때는 FixedUpdate를 사용하게 된다.

# 4. C# & Unity
# 4.1. 박싱 & 언박싱
* 값 타입
    * C#에서 구조체, 열거 타입 등은 값 타입이다
    * System.ValueType 로부터 항상 상속
    * 스레드 스택에 할당이 된다.
* 참조 타입
    * C#에서 모든 클래스는 참조 타입이 된다.    
    * System.Object로부터 상속
    * 힙에 저장이 되며 GC가 관리하게 된다.
        * 이 힙 메모리의 주소를 가리키는 값은 스택에 저장이 된다.

박싱과 언박싱의 차이:

* 박싱: 값 타입을 참조 타입으로 변경
* 언박싱: 참조 타입을 값 타입으로 변경

이며 이 둘의 작업은 기본 작업들에 비해 비용이 크기 때문에 가급적 사용하지 않는게 좋다.  
다시 박싱, 언박싱하는 과정을 통해서 힙에 가비지가 쌓여 GC에 무리를 줄 수 있는 작업이기 때문이다.

이를 해결하기 위해서는 가급적 제네릭을 활용해 줘야 한다.

# 4.2. 직렬화 & 역직렬화
### 정의
직렬화는 특정 객체를 바이트 단위로 변경한 뒤 디스크에 저장하거나 네트워크로 보낼 수 있게 만들어주는 것이다.     
역직렬화는 직렬화된 바이트 배열을 원래 객체로 변경하는 과정을 의미한다.

### 직렬화 이유
직렬화는 현재 사용하고 있는 데이터에 대해서 영속성을 부여하기 위함이다.     
영속성은 프로그램을 종료하더라도 사라지지 않는 특성을 의미한다.

이런 식으로 프로그램 종료 후에도 객체에 관한 정보를 남겨두고 싶을 때 직렬화를 사용하게 된다.    
주로 플레이어의 데이터들이 이에 속하게 된다.

### 유니티에서 직렬화가 되는 것들
모든 요소들이 직렬화 되어 저장할 수 있는 상태가 되는 건 아니다.     
또한 유니티의 경우에는 다른 언어들과는 살짝 다르게 동작할 수 있으니 아래 내용을 알아두어야 한다.

* public이거나 [SerializeField] 속성이 있어야 한다
* static, const, readonly가 아니어야 한다
* 직렬화 할 수 있는 필드 타입이 있어야 한다     
=> 직렬화 할 수 있는 필드 타입은 아래와 같다    
    * [Serializable] 속성이 있는 비추상, 비일반 커스텀 클래스
    * [Serializable] 속성이 있는 커스텀 구조체
    * UnityEngine.Object 에서 파생된 오브젝트에 대한 참조
    * int, double, bool 같은 기본 데이터 형식
    * 열거형 타입
    * Vector2, Vector3, Color 등과 같은 특정 Unity 내장 타입

# 4.3. const vs readonly
C++과 다르게 C#에서는 readonly 가 있어 수정이 안되는 읽기 전용 키워드를 제공하고 있다.  
이 둘의 차이를 간단하게 정리하면 아래와 같다:

* const
    * 컴파일 타임 상수 (컴파일 시 변수가 값으로 대체)
    * 스택에 위치하게 된다
    * 선언과 동시에 값을 할당
    * 내장 자료형에만 사용 가능
        * 때문에 사용자 정의 클래스로는 불가능
* readonly
    * 런타임 상수 (런타임에 상수에 대한 참조)
    * 힙에 위치하게 된다
    * 생성자에서 초기화 가능 (그 외 변경 불가능)
    * 어떤 타입과도 사용 가능

### const 보다는 readonly가 좋다
둘 중 가장 큰 차이는 readonly는 상수에 대한 참조 코드를 생성한다는 점이다.  
때문에 const의 값을 변경하게 된다면 이를 사용하는 곳은 전부 재컴파일을 해야 한다.   
만일 재컴파일 하지 않으면 이전의 const 값으로 되어 있어 문제가 될 수 있다.  
다만 readonly의 경우에는 일부만 리빌드 해도 이를 사용하는 다른 코드들은 참조를 가지고 있으므로 리빌드 없이 올바르게 사용이 가능하다.

그 외 const는 스택에 있어 빠르다는 장점을 가지고 있지만 그 외의 유연성이 떨어지기에 아래 경우들을 제외하고 가급적 readonly를 사용하는게 좋다.

* 특성의 매개변수
* switch/case 문의 레이블
* enum 정의

# 4.4. string
C#에서의 string은 immutable(불변) 속성을 가지고 있다.   
string이 이렇게 불변속성이 된 이유는 멀티스레드 환경을 고려해 여러 스레드들이 엑세스 할 때 이들에 대한 동기화 처리를 하는 것보다 변경이 안되게 읽기 전용으로 만드는게 값이 더 싸다고 생각한 것이다.

때문에 string에 대한 조작(+=, -= 등)을 하게 되면 이전의 객체에서 복사 후 연산을 한 뒤 이를 대입해주므로 이전의 객체는 가비지가 되어 이후 GC의 처리를 받게 된다.     
때문에 수정이 많이 일어나는 문자열로 예상이 된다면 StringBuilder 등의 클래스를 사용하는게 좋다.

### StringBuilder가 string 보다 수정에 용이한 이유
StringBuilder는 기본적으로 16문자를 담을 수 있는 자리를 잡는다.     
이렇게 할당 된 크기 내에서는 어떠한 수정을 해도 가비지가 생성되지 않는다.

만일 미리 할당한 버퍼가 다 찬 상태에서 append를 하게 되면 새 버퍼를 할당한 뒤 버퍼간 링크를 구성한다고 한다.

# 4.5. Garbage Collector
C#과 C++의 대표적인 차이가 GC의 유무다.

일단 C#, 즉 .Net의 GC는 Mark and Sweep 알고리즘을 사용하고 있다.    
이를 간단하게 설명하면 아래와 같다:

* 전역 변수, 현재 함수의 로컬 변수 등을 Root로 잡게 된다
* 이 Root를 기반으로 점점 참조를 타고 다니면서 방문한 것들을 Mark 해준다
* 이러한 Mark 작업이 끝나게 된다면 이후 Sweep 단계로 진입한다
* Sweep 단계에서는 Mark 되지 않은 것들을 가비지로 판단해 처리하게 된다

이런 작업을 거쳐 GC가 동작을 하게 된다.

### .Net과 Unity의 GC
일단 내부적으로 GC의 알고리즘은 Mark and Sweep 을 기반으로 하게 되는데 그 이후의 과정이 다르게 된다.

.Net에서는 0~2세대까지 총 3개의 세대를 통해서 관리를 하게 된다.

유니티에서는 Boehm-Demers-Weiser 라는 알고리즘을 통해 GC 작업을 하게 된다.  
Mark and Sweep 인것은 같으나 세대 구분이 없고 메모리 정렬도 없다.   
때문에 19 버전 이상에서 제공하게 되는 점진적 GC 작업을 활용하거나 오브젝트 풀링 등의 기법을 활용해서 최대한 최적화를 해줘야 할 필요가 있다.

### 상호 참조 해결법
만일 두 객체가 서로 참조중이라 하더라도 외부에서 참조가 없어 Mark 되지 않는다면 Sweep 단계에서 해체된다.

# 4.6. delegate & event
### delegate
C# 에서 델리게이트는 함수를 타입화 한 것이다.    
파라미터와 리턴 타입을 통해 정의하게 되며 이후 리턴, 파라미터 타입이 같은 메서드들과 호환되어 이 메서드들에 대한 참조를 가질 수 있게 된다.

```c#
public delegate void VoidAndIntEx(int i);

public class ExampleClass
{
    public void DoSomething(VoidAndIntEx exFunc)
    {
        // 인자로 받은 함수를 호출한다
        exFunc(1);
    }
}
```

C#에서 이런 델리게이트를 활용해 메서드를 담아두는 역할을 하거나 함수 인자로 넘겨 콜백 패턴을 구현하는 등 다양한 곳에 사용하게 된다.

### event
이벤트는 결과적으로 델리게이트와 비슷한 일을 하게 되지만 한 가지 큰 차이점은 이벤트를 호출 할 수 있는건 해당 이벤트를 가진 클래스만 가능하다는 것이다.

```c#
class ExampleClass
{
    public event Action ExampleEvent;

    // ...
    if(ExampleEvent != null)
    {
        ExampleEvent();
    }
}
```

### Action, Func, Predicate
이 키워드들은 자주 사용하게 되는 델리게이트를 템플릿화 한 것들이다.

* Action
    * 함수 파라미터가 T 이고 반환값이 void 인 경우
* Func<T, TResult>
    * 함수 파라미터가 T 이고 반환값이 TResult 인 경우
* Predicate
    * 함수 파라미터가 T 이고 반환값이 bool 인 경우

### null 조건부 연산
델리게이트나 이벤트를 다루다 보면 null인지 체크를 해줘야 한다.  
만일 null인 델리게이트를 호출한다면 NullReferenceException이 발생하게 된다.

```c#
if(ExampleEvent != null) {
    ExampleEvent();
}
```

위 코드에서 문제점은 2가지 있다.

* 멀티스레드에서 호출할 경우의 문제
* 코드가 길어짐

멀티스레드에서 문제는 복잡하게 된다.    

```c#
if(ExampleEvent != null) // 여기선 문제가 생기지 않으나
{
    // 여기서 다른 스레드가 구독을 취소해서 null이 된다
    ExampleEvent(); // NullReferenceException
}
```

이런 복잡한 문제는 검출이 어렵기에 아래 '복사 후 실행' 이란 방법을 통해서 예방할 수 있다.

```c#
var CopiedEvent = ExampleEvent;

if(CopiedEvent != null)
{
    // 여기서 ExampleEvent 구독 취소 해도 문제 생기지 않음
    CopiedEvent();
}
```

다만 이 경우 위에 언급한 '코드가 길어진다'는 문제는 해결하지 못한다.    
매번 복사하는 것도 좋은 방안은 아니다.

때문에 ?. 연산자를 활용한다.    
?. 연산자는 ? 왼쪽의 항이 null이 아니라면 . 뒷부분을 실행하겠다는 의미의 연산자이다.

```c#
ExampleEvent?.Invoke();
```

함수의 경우 Invoke 를 붙여서 호출할 수 있게 된다.   
그리고 이 연산자의 경우 원자적으로 수행이 되는 연산자라서 이 연산 도중 다른 스레드가 개입할 여지가 없어 멀티 스레드 환경에서도 안전하게 작동하게 된다.

# 4.7. this
### 클래스의 현재 인스턴스 this
흔히 다른 언어에서도 지원하는 것으로 클래스의 현재 인스턴스를 가리키는 키워드이다.  
매개변수 이름과 클래스 필드가 이름이 같다면 this로 구분할 수 있게 된다.

클래스 내에서 클래스 필드를 사용할 때는 다 this가 생략된 경우라고 볼 수 있다.

### 생성자 this()
생성자의 이름은 클래스 이름과 동일해야 하며 void 형식이어야 한다.

```c#
class MyClass
{
    int a;
    int b;

    public MyClass()
    {
        a = 10;
    }

    public MyClass(int b)
    {
        a = 10;
        this.b = b;
    }
}
```

다만 이 경우 너무 중복되는 코드들이 양산될 수 있어서 this() 생성자를 사용하는 것이다.   
this()는 자기 자신의 생성자를 가리키며 이는 생성자에서만 활용이 가능하다.

```c#
class MyClass
{
    int a;
    int b;

    public MyClass()
    {
        a = 10;
    }

    public MyClass(int b) : this()
    {
        this.b = b;
    }
}
```

this() 키워드는 생성자를 가리키기에 인자를 줘서 인자를 받는 다른 생성자를 가리킬 수도 있다.

### 정적 함수 파라미터의 this
```c#
public static void Shuffle<T>(this IList<T> list)
```

정적 함수 파라미터에 사용하는 this는 확장 메서드를 만드는데 사용되는 키워드이다.    
이를 활용하면 멤버 함수를 호출하듯 함수를 호출할 수 있게 된다.

```c#
List<MyClass> exList = new List<MyClass>();
// ...
Shuffle(exList); // 이렇게도 가능하고
exList.Shuffle(); // 이렇게도 가능하다, this 파라미터 덕분에
```

이런 식으로 클래스나 인터페이스를 확장할 수 있게 된다.

다만 기존 클래스의 함수와 동일한 시그니처로 정의하면 호출되지 않게 된다.    
이 이유는 확장 메서드는 컴파일 타임에 바인딩이 되는데 컴파일러가 함수 호출을 볼 때 인스턴스 함수를 먼저 보게 되고 그 다음 확장 메서드를 보게 된다.  
때문에 확장 메서드가 우선순위에서 밀려 호출되지 않게 되는 것이다.

# 4.8. List, Dictionary 등 자료구조의 내부
### 내부 자료구조
|컨테이너|자료구조|
|---|---|
|List<>|배열|
|SortedSet<>|레드-블랙 트리|
|HashSet<>|해시 테이블|
|Dictionary<,>|해시 테이블|
|SortedList<,>|배열|
|SortedDictionary<,>|레드-블랙 트리|

### List vs vector
List는 C++의 vector와 유사하게 동작하며 메모리에는 배열처럼 올라가게 된다.  
또한 원소 삽입이 있을 때 List의 용량을 초과하게 되면 새 공간을 할당해 기존 원소들을 복사해 가기에 최대 O(N) 시간 복잡도를 가지게 될 수도 있다.

(Remove의 경우 따로 용량 변화가 없다)

### SortedSet = set, HashSet = unordered_set
내부적으로 레드-블랙 트리를 사용하는 자료구조들의 경우 정렬된 완전 이진트리 이므로 삽입, 삭제에 있어서 O(logN) 시간이 소요되며 해시를 사용하는 자료구조들은 대부분 O(1)이지만 최악의 경우 O(N)이 될 수 있음을 알아야 한다.

### Dictionary vs SortedDictionary
대부분의 경우에서 성능은 Dictionary가 더 뛰어나다.  
삽입에는 Dictionary가 약 3배 빠를 수 있고, 검색에는 아주 근소한 차이로 SortedDictionary가 빠를 수 있다.

때문에 항시 정렬된 상태로 데이터를 저장하는 것 외에는 Dictionary 사용이 더 좋다.

# 4.9. C# vs C++
### GC
C#의 GC는 Mark and Sweep 알고리즘에 기반을 두고 있으므로 힙에 할당된 객체에 대한 포인터 추적을 실행하게 된다.   
이로 인해서 C++의 생성-소멸 주기보다는 오버헤드가 걸린다.   
그리고 수많은 객체들을 생성한 후 나중에 GC를 돌리게 되면 더 많은 시간을 사용하게 되므로 속도가 더 느려지게 된다.

C#은 세대 기반 알고리즘을 도입해 '살아 있을 가능성이 있는 객체'를 뒤로 물러나게 해 GC 시간을 줄이는 등의 노력을 하고 있다.  

### 가상 머신
'VM을 사용하면 느리다'라는 말이 나오는 주된 이유는 초기 구동시에 JIT 컴파일러를 위해 한번 대기하는 과정이 있어서 라고 한다.     
다만 이 경우 한번 실행이 되면 이후에는 여러번 사용할 수 있기에 이에 대한 오버헤드를 잘 살펴봐야 한다.

일단 C++로 작성된 프로그램은 대부분 32비트 코드로 컴파일이 되며 64비트 프로세서에서도 32비트로 돌아가게 된다.   
JIT를 사용하는 C#의 경우 타겟 플랫폼에 대한 이해도를 가질 수 있어서 64비트에 맞춰 컴파일을 한다.    
떄문에 이런 부분에 있어서 장점을 가질 수도 있다.

# 5. 로컬 좌표 & 월드 좌표
유니티에서의 로컬 좌표와 월드 좌표는 게임 오브젝트의 위치와 회전을 다루는 데 사용되는 개념이다.     

1. 로컬 좌표(Local Coordinates):    
로컬 좌표는 게임 오브젝트 자체의 지역 좌표 시스템을 나타낸다.   
각 게임 오브젝트는 자신만의 로컬 좌표 시스템을 가지며, 이를 기준으로 해당 오브젝트의 위치, 회전 및 크기를 정의한다.     
로컬 좌표 시스템의 원점은 게임 오브젝트의 중심이다.     
즉, 오브젝트의 위치는 이 로컬 좌표 시스템 내애서 상대적으로 표현된다.   
로컬 변환(이동, 회전, 크기 조절)은 해당 오브젝트 자체에만 영향을 미치며, 다른 오브젝트에 영향을 주지 않는다.
2. 월드 좌표(World Coordinates):    
월드 좌표는 게임 세계 전체의 전역 좌표 시스템을 의미한다.   
모든 게임 오브젝트는 월드 좌표 시스템 내에서 위치하며, 이 좌표 시스템은 모든 오브젝트 간의 절대적인 위치와 상대적인 위치를 나타낸다.    
오브젝트의 월드 좌표는 게임 세계 안에서의 실제 위치를 나타낸다.     
다른 오브젝트와의 상호작용, 충돌 검사 및 위치 계산은 주로 월드 좌표를 기반으로 수행된다.

로컬 좌표와 월드 좌표 간의 변환은 오브젝트의 계층 구조와 부모-자식 관계에 의해 결정된다.    
부모 오브젝트의 변환은 자식 오브젝트에 영향을 미친다.   
즉, 부모 오브젝트의 로컬 변환은 자식 오브젝트의 월드 좌표에 영향을 준다.

유니티에서는 'Transform' 컴포넌트를 사용하여 오브젝트의 로컬 및 월드 변환 정보를 관리하고 조작할 수 있다.   
이를 통해 오브젝트의 위치, 회전 및 크기를 다루며, 게임 내에서 상호작용과 위치 계산을 용이하게 할 수 있다.

# 5.1. 로컬 회전 & 월드 회전
1. 로컬 회전(Local Rotation):   
로컬 회전은 게임 오브젝트의 자체적인 회전 변환을 나타낸다.      
각 게임 오브젝트는 자신만의 로컬 좌표 시스템을 가지며, 이 좌표 시스템을 기준으로 회전이 적용된다.   
오브젝트의 로컬 회전을 변경하면 해당 오브젝트의 모양이 회전하게 된다.   
로컬 회전은 해당 오브젝트만을 기준으로 적용되며, 다른 오브젝트에 영향을 주지 않는다.
2. 월드 회전(World Rotation):   
월드 회전은 게임 세계 전체의 좌표 시스템을 기준으로 한 회전 변환을 의미한다.    
오브젝트의 월드 회전을 변경하면 해당 오브젝트가 전체 게임 세계 내에서 회전하게 된다.    
월드 회전은 다른 오브젝트와의 상호작용, 충돌 감지, 위치 계산 등과 관련된 중요한 개념이다.

로컬 회전과 월드 회전 간의 차이점은 오브젝트의 부모-자식 계층 구조에 기인한다.      
부모 오브젝트의 로컬 회전이 변경되면, 자식 오브젝트의 로컬 회전에도 영향을 줄 수 있다.  
그에 반해 월드 회전은 게임 세계 전체에 적용되며, 부모 오브젝트의 변환과 상관없이 독립적으로 작동한다.

유니티에서 오브젝트의 로컬 및 월드 회전을 조작하려면 'Trasform' 컴포넌트의 'localRotation' 및 'rotation' 속성을 사용한다.   
로컬 회전은 오브젝트의 로컬 좌표 시스템을 기준으로 하며, 월드 회전은 게임 세계 전체를 기준으로 한다.    
이를 이용하여 오브젝트의 회전을 원하는 방식으로 조작할 수 있다.

# 6. 센터 & 피벗
유니티에서의 "센터(center)"와 "피벗(pivot)"은 게임 오브젝트의 위치와 회전을 조작할 때 중요한 개념이다.

1. 센터(Center):    
게임 오브젝트의 센터는 해당 오브젝트의 로컬 좌표 시스템에서의 중심 지점을 의미한다.     
이것은 오브젝트가 어디에 위치하는지를 나타내며, 오브젝트의 로컬 공간 내에서 중심점으로 간주된다.    
예를 들어, 큐브 오브젝트의 센터는 큐브의 중심으로 간주된다.     
센터를 기준으로 오브젝트의 위치가 결정된다.
2. 피벗(Pivot):     
게임 오브젝트의 피벗은 해당 오브젝트를 회전할 때 중심이 되는 지점이다.      
피벗은 오브젝트의 로컬 좌표 시스템 내에서 설정되며, 오브젝트의 회전 중심을 정의한다.    
회전 시에 피벗은 오브젝트 주위를 중심으로 회전하게 되며, 오브젝트의 로컬 공간 내에서만 영향을 미친다.   
피벗을 변경하면 오브젝트의 회전 동작이 변경될 수 있다.

유니티에서는 오브젝트의 센터와 피벗을 조작할 수 있는 방법이 있다.   
일반적으로는 오브젝트를 생성할 때 기본적으로 센터와 피벗이 정의되며, 이후에도 편집할 수 있다.   
센터와 피벗을 조작하면 오브젝트의 위치와 회전 동작을 원하는 대로 조절할 수 있다.    
이것은 모델의 정렬, 애니메이션, 게임 플레이 등에 활용될 수 있다.

오브젝트의 센터와 피벗을 조작하려면 유니티의 에디터 내에서 해당 오브젝트를 선택한 후 'Transform' 컴포넌트의 인스펙터에서 'Position'과 'Rotation' 값을 조정하면 된다.    
또한 몇몇 경우에는 별도의 툴이나 스크립트를 사용하여 센터와 피벗을 조작하는 것이 유용할 수 있다.

# 7. 기즈모
유니티의 "기즈모(Gizmo)"는 에디터 상에서 시각적으로 오브젝트의 위치, 회전, 크기 등을 보여주고 조작할 수 있는 도구 및 표시 요소를 말한다.    
기즈모는 게임 개발자가 에디터 내에서 씬(Scene)을 구성하고 조작하는 데 도움을 주는 중요한 기능 중 하나이다.

기즈모는 다양한 유형의 오브젝트와 관련하여 나타날 수 있으며, 주로 다음과 같은 목적으로 사용된다:

1. 트랜스폼 조작: 기즈모를 사용하여 선택한 게임 오브젝트의 위치, 회전 및 크기를 조작할 수 있다.     
에디터 내에서 직접 조작하거나, 값을 입력하여 오브젝트의 변환 정보를 수정할 수 있다.
2. 충돌 검사 및 위치 조정: 기즈모를 사용하여 충돌 검사를 수행하거나 오브젝트를 정확한 위치로 이동시킬 수 있다.      
이를 통해 게임 오브젝트 간의 상호작용을 시각적으로 확인하고 조정할 수 있다.
3. 애니메이션 및 경로: 기즈모를 사용하여 애니메이션 및 경로의 편집을 수행할 수 있다.    
이를 통해 애니메이션의 키 프레임을 조작하거나, 경로를 시각적으로 수정할 수 있다.
4. 씬 구성: 기즈모를 사용하여 씬 내의 오브젝트들을 배치하고 정렬할 수 있다.     
예를 들어, 오브젝트 간의 거리나 간격을 정확하게 조절할 때 사용할 수 있다.

유니티는 다양한 기본 기즈모를 제공하며, 개발자는 이를 확장하거나 사용자 정의하여 자신의 요구에 맞게 사용할 수 있다.     
기즈모를 활용하여 오브젝트의 변환 정보를 직접 조작하거나 시각적으로 확인함으로써 게임의 개발 및 디버깅 프로세스를 더욱 효율적으로 수행할 수 있다.

# 8. 회전
유니티에서 회전은 게임 오브젝트의를 중심으로 축을 기준으로 회전 변환을 적용하는 것을 의미한다.      
회전은 오브젝트의 방향이나 모양을 변경하는 데 사용된다.     
유니티에서 회전은 오브젝트의 'Transform' 컴포넌트를 통해 조작할 수 있다.

회전은 주로 세 가지 요소로 정의된다:

1. 오일러 각(Euler Angles):     
오일러 각은 X, Y, Z 축 주위의 회전을 나타내는 값으로, 각 축의 회전을 독립적으로 지정할 수 있다.     
그러나 오일러 각은 "짐벌 락(Gimbal Lock)"이라는 문제를 가지고 있어 복잡한 회전 동작에 사용하기에는 제한이 있을 수 있다.
2. 쿼터니언(Quaternion):    
쿼터니언은 회전을 나타내는 더 강력하고 안정적인 표현 방식이다.      
유니티에서는 주로 쿼터니언을 사용하여 회전을 표현하며, 회전 연산을 수행할 때 좀 더 정확하고 예측 가능한 결과를 얻을 수 있다.
3. 회전 행렬(Rotation Matrix):      
회전 행렬은 3x3 행렬로, 회전 변환을 수행하는 데 사용된다.   
유니티는 내부적으로 회전 행렬을 사용하여 회전을 처리하지만, 일반적으로 직접 회전 행렬을 조작하는 경우는 드물다.

오브젝트의 회전은 주로 다음과 같은 용도로 활용된다:

- 방향 제어: 오브젝트의 회전을 조작하여 원하는 방향을 향하도록 만들 수 있다.    
주로 캐릭터나 카메라의 방향을 제어하는 데 사용된다.
- 애니메이션: 회전을 조작하여 애니메이션을 만들거나 조정할 수 있다.     
쿼터니언을 이용하면 부드럽고 정확한 회전 동작을 표현할 수 있다.
- 게임 오브젝트의 모양 변경: 오브젝트의 회전을 변경하여 모양을 바꾸거나, 물체를 기울이는 등 다양한 시각적 효과를 구현할 수 있다.

유니티에서 회전을 조작하려면 'Transform' 컴포넌트의 'rotation' 속성을 수정하면 된다.    
회전을 설정하거나 변경하면 오브젝트의 방향과 모양이 변화한다.   
또한 오브젝트의 부모-자식 관계나 로컬-월드 변환에 따라 회전이 영향을 받을 수 있다.

# 9. 이동
유니티에서의 이동은 게임 오브젝트를 움직이는 작업을 의미한다.   
이동은 게임 세계 내에서 오브젝트의 위치를 변경하는 것을 말하며, 주로 게임 캐릭터, 카메라, 아이템 등을 제어하거나 배치하는 데 사용된다.      
유니티에서 오브젝트의 이동은 'Transform' 컴포넌트를 통해 조작할 수 있다.

오브젝트의 이동은 크게 두 가지 방식으로 다루어진다:

1. 절대적인 이동(Absolute Movement):    
절대적인 이동은 원하는 위치로 오브젝트를 직접 이동시키는 것을 의미한다.     
이동하려는 목표 위치를 정확하게 지정하여 오브젝트를 이동시킨다.     
이동 후에는 오브젝트의 위치가 목표 위치로 설정된다.
2. 상대적인 이동(Relative Movement):    
상대적인 이동은 오브젝트의 현재 위치를 기준으로 상대적인 방향과 거리를 지정하여 이동시키는 것을 의미한다.   
현재 위치에서 상대적인 이동 값을 더하거나 빼서 새로운 위치를 계산하여 오브젝트를 이동시킨다.    

오브젝트의 이동은 다음과 같은 용도로 사용된다:

- 캐릭터 이동: 플레이어 캐릭터나 NPC를 이동시켜 게임 내에서 움직이는 동작을 구현한다.   
- 카메라 제어: 카메라를 이동시켜 다른 시점에서 게임을 관찰하거나 특정 위치를 초점으로 하는 등의 효과를 만든다.
- 아이템 배치: 아이템이나 물체를 원하는 위치에 배치하거나 이동시켜 게임 환경을 구성한다.
- 애니메이션: 이동을 사용하여 캐릭터의 걸음, 뛰기 등의 애니메이션을 만들거나 제어할 수 있다.

유니티에서 오브젝트의 이동은 'Transform' 컴포넌트의 'position' 속성을 조작하여 수행할 수 있다.      
이를 통해 절대적인 이동이나 상대적인 이동을 구현하고 오브젝트의 위치를 원하는 대로 조작할 수 있다.

# 10. 리지드 바디
유니티에서의 "Rigidbody"는 물리 엔진과 상호작용하여 게임 오브젝트에 물리적인 특성과 동작을 부여하는 컴포넌트이다.   
이 컴포넌트를 사용하면 게임 오브젝트가 중력, 충돌, 운동 등의 물리적 현상에 따라 움직이거나 상호작용할 수 있다.

Rigidbody는 주로 물리 시뮬레이션을 통해 오브젝트 간의 상호작용이나 환경과의 상호작용을 모델링하는 데 사용된다.      
일반적으로 물체가 중력에 따라 떨어지거나, 충돌 시 힘을 받아 움직이거나 튀어오르는 등의 동작을 구현할 때 유용하다.

Rigidbody의 주요 속성과 기능은 다음과 같다:

1. 질량(Mass): 물체의 질량을 나타낸다.      
질량이 큰 물체는 중력에 더 많이 영향을 받으며, 충돌 시 힘을 더 받게 된다.
2. 중력(Gravity): 물체에 중력 효과를 적용할지 여부를 결정한다.  
중력을 켜면 물체는 아래로 떨어지게 된다.    
3. 운동(Forces): 힘 또는 속도를 적용하여 물체를 움직이거나 회전시킬 수 있다.    
'AddForce'나 'AddTorque' 메서드를 사용하여 힘을 추가할 수 있다.
4. 물리 충돌(Collision): Rigidbody를 가진 물체는 다른 Collider와 충돌할 때 물리적인 효과를 받는다.  
충돌을 통해 움지깅거나 튀어오르는 등의 동작이 발생할 수 있다.
5. 중력 조정(Gravity Scale): 중력 효과를 물체 별로 조정할 수 있다.      
이를 통해 다양한 물리적 동작을 만들 수 있다.

유니티에서 Rigidbody 컴포넌트는 주로 3D 물리 시뮬레이션에서 사용되며, 2D 게임에서는 'Rigidbody2D' 컴포넌트가 사용된다.  
Rigidbody를 사용하려면 게임 오브젝트에 해당 컴포넌트를 추가하고, 필요한 속성 및 메서드를 활용하여 물리적 동작을 구현하면 된다.

# 10.1. AddForce
유니티에서의 'AddForce'는 Rigidbody 컴포넌트를 가진 게임 오브젝트에 힘(Force)을 추가하여 물체를 움직이거나 회전시키는 메서드이다.   
이 메서드는 물리 시뮬레이션을 사용하여 게임 오브젝트에 힘을 적용할 때 주로 사용된다.

'AddForce' 메서드는 게임 오브젝트에 힘을 방향과 크기를 지정하여 추가한다.   
이를 통해 게임 오브젝트를 움직이게 하거나 회전시키는 데 사용할 수 있다.     
주로 Rigidbody 컴포넌트를 가진 물체들을 물리 시뮬레이션에 따라 움직이거나 튀어오르게 만들 때 사용된다.

예를 들어, Rigidbody를 가진 공에 힘을 주어 공을 움직이게 하는 경우:
```c#
public Rigidbody ballRigidbody;
public Vector3 forceDirection = Vector3.forward;
public float forceMagnitude = 10.0f;

void Update()
{
    if (Input.GetKeyDown(KeyCode.Space))
    {
        ballRigidbody.AddForce(forceDirection * forceMagitude);
    }
}
```

위의 예제에서 'AddForce' 메서드를 사용하여 'ballRigidbody'에 'forceDirection' 방향으로 'forceMagnitude' 크기의 힘을 추가하고 있다.      
이로 인해 공은 해당 방향으로 움직이게 된다.

'AddForce' 메서드는 게임 오브젝트에 물리적인 힘을 적용할 때 유용하며, 주로 게임에서 물리 시뮬레이션을 활용하여 물체의 움직임을 제어하거나 상호작용을 구현할 때 사용된다.

# 10.2. AddTorque
유니티에서의 'AddTorque'는 Rigidbody 컴포넌트를 가진 게임 오브젝트에 회전 토크(Torque)를 추가하여 물체를 회전시키는 메서드이다.     
이 메서드는 물리 시뮬레이션을 활용하여 게임 오브젝트를 회전시키는 데 사용된다.

'AddTorque' 메서드는 회전 토크의 크기와 방향을 지정하여 게임 오브젝트에 회전 효과를 추가한다.   
이를 통해 Rigidbody를 가진 물체의 회전 동작을 제어할 수 있다.   
주로 고체 물리학에서 물체의 회전을 모델링하거나 물체를 특정한 각속도로 회전시키는 데 사용된다.

예를 들어, Rigidbody를 가진 톱날 모양의 오브젝트에 회전 토크를 추가하여 회전시키는 경우:
```c#
public Rigidbody bladeRigidbody;
public Vector3 torqueDirection = Vector3.up;
public float torqueMagnitude = 5.0f;

void Update()
{
    if (Input.GetKeyDown(KeyCode.Space))
    {
        bladeRigidbody.AddTorque(torqueDirection * torqueMagnitude);
    }
}
```

위의 예제에서 'AddTorque' 메서드를 사용하여 'bladeRigidbody'에 'torqueDirection' 방향으로 'torqueMagnitude' 크기의 회전 토크를 추가하고 있다.   
이로 인해 톱날 모양의 오브젝트가 해당 방향으로 회전하게 된다.

'AddTorque' 메서드는 게임 오브젝트에 회전 효과를 추가할 때 사용되며, 주로 물리 시뮬레이션을 통해 오브젝트의 회전 동작을 제어하고 다양한 회전 동작을 구현할 때 활용된다.

# 11. 콜라이더
유니티에서의 "Collider"는 게임 오브젝트가 다른 오브젝트와 상호작용하고 충돌을 감지할 수 있도록 도와주는 컴포넌트이다.   
콜라이더는 주로 물리 시뮬레이션과 충돌 감지에 사용되며, 게임 환경에서 오브젝트 간의 상호작용을 모델링하는 데 중요한 역할을 한다.

콜라이더는 게임 오브젝트의 형태를 정의하고 다른 오브젝트와의 경계를 나타내며, 주변 오브젝트와 상호작용할 때 물리적 동작이나 충돌 검사를 수행한다.   
콜라이더를 사용하여 오브젝트 간의 충돌이나 상호작용을 처리할 수 있다.

주요한 콜라이더 종류는 다음과 같다:

1. 박스 콜라이더(Box Collider): 박스 모양의 콜라이더로, 주로 상자 모양의 충돌 영역을 정의하는 데 사용된다.
2. 구 콜라이더(Sphere Collider): 구 모양의 콜라이더로, 주로 둥근 모양의 충돌 영역을 정의하는 데 사용된다.
3. 캡슐 콜라이더(Capsule Collider): 실린더 모양의 콜라이더로, 주로 원통 형태의 충돌 영역을 정의하는 데 사용된다.
4. 메쉬 콜라이더(Mesh Collider): 복잡한 형태의 콜라이더로, 3D 모델의 형태를 따라가며 충돌 영역을 정의하는 데 사용된다.
5. 터레인 콜라이더(Terrain Collider): 지형 모양의 콜라이더로, 지형 오브젝트의 지형 표면에 충돌 영역을 정의하는 데 사용된다.

콜라이더는 충돌 감지를 위해 사용되며, 오브젝트 간의 충돌이나 상호작용을 처리하려면 콜라이더를 가진 오브젝트 간의 상호작용을 처리하는 스크립트를 작성해야 한다.  
콜라이더와 Rigidbody 컴포넌트를 조합하여 오브젝트 간의 물리적 상호작용을 정밀하게 제어하고 게임의 리얼리즘을 높일 수 있다.

# 12. Lerp
유니티에서의 "Lerp"는 "선형 보간(Linear Interpolation)"을 의미하는 용어다.    
선형 보간은 두 지점 사이를 일정한 비율로 보간하여 새로운 값을 만들어내는 방법을 말한다.     
Lerp 함수는 시작 값과 끝 값 사이에서 선형 보간을 수행하며, 주로 애니메이션 및 값의 부드러운 변화를 구현하는 데 사용된다.

유니티의 'Mathf.Lerp' 함수나 'Vector3.Lerp', 'Quaternion.Lerp' 등의 메서드는 선형 보간을 사용하여 두 값 사이를 부드럽게 변화시키는 데 유용하다.     
이 함수들은 주로 두 가지 값 사이를 특정 비율로 보간하는 데 사용된다.

예를 들어, 두 위치 A와 B 사이를 t라는 비율로 보간하려고 할 때:
```c#
Vector3 interpolatedPosition = Vector3.Lerp(A, B, t);
```

여기서 't' 값은 0부터 1 사이의 값으로, 0에 가까울수록 결과 값은 A에 가까워지고, 1에 가까울수록 B에 가까워진다.      
't' 값을 조절하여 A와 B 사이를 원하는 비율로 부드럽게 이동하는 효과를 얻을 수 있다.

선형 보간은 애니메이션의 프레임 간 보간, 오브젝트의 이동 및 회전 애니메이션, 값의 부드러운 전환 등 다양한 상황에서 사용되며, 유니티의 애니메이션 및 게임 개발 프로세스에서 중요한 역할을 한다.

# 13. 델타 타임
유니티에서의 'Time.deltaTime'은 프레임 간의 경과 시간을 나타내는 값이다.    
이 값은 게임의 프레임 속도에 따라 변화하며, 게임의 부드러운 애니메이션 및 물리 시뮬레이션을 위해 주로 사용된다.

'Time.deltaTime'은 초 단위로 현재 프레임과 이전 프레임 사이의 경과 시간을 나타낸다.     
이 값을 이용하면 프레임 간의 시간 간격을 고려하여 오브젝트의 이동, 회전, 애니메이션 등을 조절할 수 있다.    
게임의 프레임 속도가 고정되어 있지 않은 경우에도 'Time.deltaTime'을 이용하면 다양한 컴퓨터 환경에서 일정한 속도로 동작하는 게임을 만들 수 있다.

보통 게임 루프 내에서 'Time.deltaTime'을 사용하여 물리 시뮬레이션과 애니메이션을 업데이트할 때, 이 값을 이용하여 값을 조절하거나 변화시킨다.    
예를 들어, 물체를 매 프레임마다 'Time.deltaTime'을 곱한 만큼 이동시키면 프레임 속도에 관계없이 일정한 속도로 이동할 수 있다.

# 14. 렌더링 파이프라인
유니티의 렌더링 파이프라인(Rendering Pipeline)은 게임에서 그래픽스를 생성하고 화면에 표시하는 과정을 나타내는 개념이다.     
렌더링 파이프라인 3D 모델의 렌더링, 조명, 그림자, 효과 등을 처리하여 게임 화면을 생성하는데 사용된다.   
유니티에서는 여러 가지 렌더링 파이프라인을 제공하며, 개발자는 이 중에서 선택하여 게임의 시각적인 품질과 성능을 조절할 수 있다.

주요한 유니티 렌더링 파이프라인은 다음과 같다:

1. Built-in Redering Pipeline(레거시 파이프라인):   
이전 버전의 유니티에서 사용되던 렌더링 파이프라인으로, 지원되지 않을 수도 있다.     
기본적인 렌더링과 조명을 처리하는데 사용된다.   
유니티 2018까지는 사용되었으나 이후 버전부터는 HDRP 및 URP로 대체되었다.
2. Universal Render Pipeline(URP):      
경량의 렌더링 파이프라인으로, 모바일 기기나 저사양 PC 등에서도 높은 성능과 시각적 품질을 제공하도록 설계되었다.     
쉐이더 그래프를 통한 시각적 효과의 생성과 경량화된 렌더링을 지원한다.
3. High Definition Render Pipeline(HDRP):   
고품질의 렌더링을 지원하는 파이프라인으로, 현실적인 조명, 그림자, 효과 등을 제공한다.   
고사양 PC 및 콘솔 기기 등에서 사용하여 고품질의 시각적 경험을 구현할 수 있다.
4. Custom Render Pipelines:     
유니티는 커스텀 렌더링 파이프라인을 만들 수 있는 기능을 제공한다.   
개발자는 자체적으로 렌더링 파이프라인을 구성하거나 확장하여 원하는 시각적 품질과 성능을 달성할 수 있다.

렌더링 파이프라인은 게임의 시각적인 품질과 성능을 결정하는 중요한 요소 중 하나이다.     
게임의 특성과 목표에 따라 적절한 렌더링 파이프라인을 선택하고 설정하여 원하는 시각적 경험을 제공할 수 있다.

# 14.1. URP
유니티의 Universal Render Pipeline(URP)는 경량 렌더링 파이프라인으로, 다양한 플랫폼과 하드웨어에서 높은 성능과 시각적 품질을 제공하기 위해 설계된 렌더링 시스템이다.    
URP는 유니티의 2019.3 버전부터 도입되었으며, 기존의 Built-in Rendering Pipeline을 대체하기 위해 만들어졌다.

URP는 다음과 같은 주요 특징을 가지고 있다:

1. 경량화: URP는 경량화된 렌더링 파이프라인으로, 모바일 기기나 저사양 PC와 같은 하드웨어에서도 효과적인 성능을 제공한다.    
이를 톨해 다양한 플랫폼에 최적화된 게임을 개발할 수 있다.
2. 쉐이더 그래프(Shader Graph): URP는 쉐이더 그래프를 통해 시각적 효과를 생성하고 조작하는 데 강력한 기능을 제공한다.   
쉐이더 그래프를 사용하여 복잡한 시각적 효과를 직관적으로 제작할 수 있다.
3. 전역 조명: 실시간 글로벌 일루미네이션(Global Illumination)을 지원하여 조명과 그림자를 보다 현실적으로 표현할 수 있다.
4. 2D 그래픽 지원: 2D 게임 개발을 위한 기능도 포함되어 있어 2D 스프라이트의 렌더링 및 조명을 효율적으로 처리할 수 있다.
5. Post-processing 효과: URP는 후처리(Post-processing) 효과를 내장하여 게임 화면에 다양한 시각적 효과를 추가할 수 있다.
6. 조작 가능한 렌더링 순서: URP는 개발자가 렌더링 단계의 순서와 플로우를 조절하고, 새로운 렌더링 기능을 추가할 수 있도록 확장성을 제공한다.

URP는 성능과 시각적 품질 사이의 균형을 잡아야 하는 프로젝트에 적합하며, 모바일 게임이나 경량 게임에서도 고품질의 그래픽을 구현하고자 할 때 유용하다.    
URP의 주요 장점은 경량화된 성능과 시각적 품질, 쉐이더 그래프의 사용 등으로 이루어져 있다.

# 14.2. HDRP
유니티의 High Definition Render Pipeline(HDRP)는 고품질 렌더링 파이프라인으로, 현실적인 시각적 품질과 그래픽 효과를 구현하기 위해 개발된 렌더링 시스템이다.     
HDRP는 유니티 2018.1 버전부터 도입되었으며, 이전의 Built-in Rendering Pipeline을 대체하고 더 높은 시각적 품질을 제공하기 위해 만들어진 파이프라인이다.

HDRP는 다음과 같은 주요 특징을 가지고 있다:

1. 고품질 렌더링: HDRP는 현실적인 조명, 그림자, 재질, 반사 등을 제공하여 게임의 시각적 품질을 대폭 향상시킨다.      
물리 기반 렌더링을 기반으로 하며, 고품질의 시각적 효과를 구현할 수 있다.
2. 실시간 글로벌 일루미네이션: HDRP는 렌더링 중에 실시간 글로벌 일루미네이션을 지원하여 조명과 그림자를 보다 현실적으로 표현할 수 있다.
3. 실시간 리플렉션: 화면에 보이는 물체 주변의 환경을 반영하여 실시간으로 반사 효과를 생성할 수 있다.
4. 반투명 마테리얼: HDRP는 반투명 마테리얼의 시각적인 부드러움을 개선하고 복잡한 투명 마테리얼을 지원한다.
5. Volumetric Fog 및 파티클 시스템: 공기 중에서 빛을 흡수하거나 반사하는 현상을 시각화하는 Volumetic Fog를 지원하며, 파티클 시스템을 통해 다양한 파티클 효과를 제작할 수 있다.
6. Custom Render Pass: 개발자가 직접 렌더링 파이프라인의 단계를 추가하거나 조작할 수 있는 Custom Render Pass 기능을 제공한다.

HDRP는 고품질의 시각적 효과와 현실적인 조명, 그림자, 재질 등을 필요로 하는 프로젝트 적합하다.   
주로 PC 게임이나 콘솔 게임에서 활용되며, 더 높은 그래픽 품질과 시각적 리얼리즘을 추구하는 프로젝트에 유용한 렌더링 파이프라인이다.

# 14.3. SRP
유니티의 SRP(Scriptable Render Pipeline)는 사용자 정의 가능한 렌더링 파이프라인을 구축하고 조정할 수 있는 프레임워크이다.     
SRP를 사용하면 유니티의 기본적인 렌더링 파이프라인을 사용자 정의 요구에 맞게 수정하거나 완전히 새로운 렌더링 파이프라인을 만들 수 있다.     
SRP는 Universal Render Pipeline(URP)와 High Definition Render Pipeline(HDRP)를 생성하고 구성하기 위한 기술적인 기반을 제공한다.

SRP를 사용하면 다음과 같은 주요 기능을 활용할 수 있다:

1. Render Pass Customization: 사용자는 렌더링 프로세스의 다양한 단계에 대한 커스텀 렌더 패스를 정의하고 추가할 수 있다.     
이를 통해 렌더링 파이프라인의 동작을 조절하거나 추가적인 기능을 구현할 수 있다.
2. Shader Customization: SRP를 통해 사용자 정의 쉐이더를 작성하거나 기존 쉐이더를 수정할 수 있다.   
이로써 특정한 시각적 효과나 마테리얼 동작을 원하는 대로 구현할 수 있다.
3. Culling Customization: 뷰 프러스텀 컬링(View Frustum Culling)과 같은 컬링 방법을 사용자의 요구에 따라 변경하거나 최적화할 수 있다.
4. Lighting and Shadow Customization: 조명과 그림자 처리를 개별적으로 조절하거나 사용자 정의할 수 있다.     
이를 통해 특정한 조명 모델이나 그림자 기술을 구현할 수 있다.
5. Post-processing Effects: 후처리 효과를 사용자가 원하는 방식으로 추가하거나 조정할 수 있다.

SRP는 주로 고급 사용자나 그래픽 엔진 개발자를 위해 고안되었다.      
기존의 Universal Render Pipeline(URP)와 High Definition Render Pipeline(HDRP)는 SRP의 구현 사례로 볼 수 있으며, 이를 통해 게임 개발자는 더 높은 수준의 커스터마이징과 시각적 품질을 달성할 수 있다.

# 15. 시네머신
유니티의 Cinemachine은 게임의 카메라 워크플로우를 간소화하고 다양한 카메라 동작을 제어하는 데 사용되는 패키지이다.      
Cinemachine을 사용하면 복잡한 카메라 애니메이션 및 전환을 더 쉽게 구현하고 조작할 수 있다.      
주로 게임 내 카메라 시스템을 개발하거나 감독하는 데 유용하게 사용된다.

Cinemachine의 주요 특징은 다음과 같다:

1. 카메라 브레인(Camera Brain): Cinemachine은 "카메라 브레인"이라는 개념을 사용하여 여러 개의 카메라 중에서 어떤 카메라를 사용할지 관리한다.    
이 브레인은 프로그래밍 로직이나 시각적 설정을 통해 다양한 상황에서 자동으로 카메라를 전환하거나 제어할 수 있다.     
2. 가상 카메라(Virtual Camera): Cinemachine은 가상 카메라를 생성하고 관리하는 데 사용된다.      
가상 카메라는 게임 내 오브젝트의 위치, 회전, 시야 등을 따라가거나 추적하여 카메라 동작을 생성한다.
3. 트랙과 블렌더(Tracks and Blends): Cinemachine은 타임라인과 같은 트랙 시스템을 사용하여 카메라 동작을 조정할 수 있다.     
또한 블렌딩 기능을 통해 서로 다른 카메라 동작을 부드럽게 전환하거나 홉한할 수 있다.
4. 애니메이션 및 물리 기반 동작: Cinemachine은 애니메이션 또는 물리 기반 동작을 사용하여 카메라를 움직이게 하거나 제어할 수 있다.   
이를 통해 자연스럽고 다양한 카메라 동작을 생성할 수 있다.
5. 리액션 시스템: Cinemachine은 게임 오브젝트와 상호작용하여 카메라 동작을 제어할 수 있는 리액션 시스템을 제공한다.     
이를 통해 플레이어의 움직임이나 상황에 맞게 카메라를 제어할 수 있다.    

Cinemachine은 별도의 패키지로 제공되며, 유니티 에셋 스토어에서 다운로드하여 사용할 수 있다.     
이를 통해 게임의 시네마틱한 효과와 전문적인 카메라 워크플로우를 더욱 간단하게 구현할 수 있다.

# 16. 코루틴 & 인보크
### 코루틴
유니티의 코루틴(Coroutine)은 비동기적인 동작을 구현하기 위해 사용되는 기능으로, 특히 게임에서 시간 지연, 반복적인 작업, 병렬 실행 등을 다루는 데 유용하다.      
코루틴을 사용하면 메인 스레드를 차단하지 않고도 여러 동작을 조절하거나 제어할 수 있다.

코루틴을 사용하여 함수를 만들면 해당 함수 내에서 'yield return' 문을 사용하여 특정 시간을 대기하거나 다른 동작을 수행하다가 다시 원래 함수로 돌아올 수 있다.    
코루틴 함수는 메인 스레드에서 실행되며, 메인 스레드의 프레임이 진행되는 동안 작업을 처리하면서도 게임의 프레임 속도에 영향을 주지 않는다.

아래는 코루틴의 간단한 예시이다:
```c#
using UnityEngine;

public class Example : MonoBehaviour
{
    private void Start()
    {
        StartCoroutine(MyCoroutine());
    }

    private IEnumerator MyCoroutine()
    {
        Debug.Log("Coroutine started");
        yield return new WaitForSeconds(2.0f);
        Debug.Log("Coroutine resumed after 2 seconds");
    }
}
```

위의 에시에서 'MyCoroutine'은 코루틴 함수다.    
'StartCoroutine' 함수를 사용하여 코루틴을 시작하고, 'yield return new WaitForSeconds(2.0f);' 라인에서 2초 동안 대기하도록 지정하고 있다.    
이러한 식으로 코루틴을 사용하면 원하는 지연이나 작업을 비동기적으로 처리할 수 있다.

코루틴은 게임 내에서 타이밍 제어, 애니메이션, 네트워킹 등 다양한 상황에서 유용하게 사용된다.    
하지만 코루틴의 사용은 복잡한 동기화 문제를 유발할 수 있으므로, 적절한 활용과 조심스런 사용이 필요하다.

### 인보크
유니티의 'Invoke'는 주어진 시간 이후에 특정 메서드를 실행하도록 예약하는 함수다.    
이를 사용하여 게임 오브젝트의 특정 동작이나 함수 호출을 지연시키거나 반복적으로 실행할 수 있다.     
일정한 시간이 지난 후에 원하는 동작을 수행하거나 주기적으로 특정 함수를 호출하는 데 유용하게 사용된다.

'Invoke' 함수의 사용 방법은 다음과 같다:
```c#
using UnityEngine;

public class Example : MonoBehaviour
{
    private void Start()
    {
        // 2초 후에 MyMethod를 호출
        Invoke("MyMethod", 2.0f);
    }

    private void MyMethod()
    {
        Debug.Log("MyMethod has been called.");
    }
}
```

위의 예제에서는 'Start' 메서드에서 'Invoke' 함수를 사용하여 2초 후에 'MyMethod' 메서드를 호출하도록 예약했다.   
지정한 시간이 경과하면 해당 메서드가 실행되어 "MyMethod has been called."라는 로그가 출력된다.

또한 'Invoke'를 사용하여 반복적으로 함수를 호출하는 것도 가능하다.      
예를 들어, 아래의 코드는 1초마다 'MyMethod'를 호출한다:
```c#
using UnityEngine;

public class Example : MonoBehaviour
{
    private void Start()
    {
        // 1초 후부터 1초 간격으로 MyMethod를 호출
        InvokeRepeating("MyMethod", 1.0f, 1.0f);
    }

    private void MyMethod()
    {
        Debug.Log("MyMethod has been called.");
    }
}
```

'InvokeRepeating' 함수를 사용하여 처음에 지정한 시간만큼 대기하고, 그 후에 주기적으로 함수를 호출하도록 예약한다.

'Invoke'와 'InvokeRepeating'은 유니티에서 간단한 시간 기반의 동작을 구현하는 데 유용하며, 예를 들어 애니메이션, 게임 로직, 상호작용 등 다양한 시나리오에서 활용할 수 있다.

# 16.1. 코루틴 & 인보크 차이점
코루틴과 Invoke는 둘 다 시간을 지연시키거나 반복적인 작업을 수행하는 데 사용되는 유니티의 기능이다.     
그러나 두 기능 간에는 몇 가지 중요한 차이점이 있다.

1. 비동기성:
    * 코루틴: 코루틴은 비동기적으로 동작하며, 메인 스레드를 차단하지 않고 다른 작업을 수행할 수 있다.   
    이는 게임의 프레임 속도에 영향을 주지 않고 시간 지연이나 반복 작업을 수행할 수 있다는 장점을 가진다.
    * Invoke: Invoke 함수는 해당 메서드가 호출되면 해당 프레임에서 지연 시간 동안 대기하며, 이는 메인 스레드를 차단하므로 별도의 스레드에서 실행되지 않는다.
2. 유연성:
    * 코루틴: 코루틴은 'yield return'을 사용하여 다양한 종류의 대기 및 동작을 지정할 수 있다.   
    특정 시간 지연 이외에도 다양한 조건에서 작동하도록 할 수 있다.
    * Invoke: Invoke는 지연 시간만 조절할 수 있으며, 미리 정의된 메서드를 호출하는 것에 주로 사용된다.
3. 코드 구조:
    * 코루틴: 코루틴은 함수 내에서 'yield return'과 함께 사용되며, 함수 내에서 여러 지점에서 실행이 중단되고 재개된다.
    * Invoke: Invoke는 특정 함수를 메서드 이름을 지정하여 호출하며, 따로 함수 내에 코드 블록을 만들 필요가 없다.
4. 반복 작업:
    * 코루틴: 코루틴은 반복 작업을 'yield return new WaitForSeconds()' 등을 사용하여 구현할 수 있다.
    * Invoke: InvokeRepeating 함수를 사용하여 주기적으로 함수를 호출하고 반복 작업을 구현할 수 있다.
5. 복잡성:
    * 코루틴: 비동기적인 특성으로 복잡한 시나리오와 작업을 다루는 데 적합하며, 상대적으로 더 유연하고 복잡한 작업을 처리하기 위해 사용된다.
    * Invoke: 단순한 지연 시간을 가진 메서드 호출에 사용되며, 간단한 작업에 적합하다.

따라서 기본적인 지연 작업이나 간단한 메서드 호출은 Invoke를 사용하는 것이 간단하고 편리할 수 있으나, 비동기적이거나 복잡한 동작을 처리하려면 코루틴을 사용하는 것이 더 적합할 수 있다.

# 16.2. 코루틴 & Update
유니티의 'Update'와 'FixedUpdate'는 게임 루프의 일부로 프레임마다 호출되는 함수이다.    
게임 오브젝트의 상태를 업데이트하거나 게임 로직을 실행하는 데 사용된다.     
하지만 이러한 메서드 내에서 긴 시간 동안 실행되는 작업을 수행하거나 반복적인 작업을 수행하면 프레임 속도에 영향을 미칠 수 있고, 원치 않은 성능 저하가 발생할 수 있다.

코루틴을 사용하여 'Update'나 'FixedUpdate'를 대체할 수 있는데, 이렇게 하면 프레임 속도에 영향을 덜 받으면서 비동기 작업이나 반복 작업을 처리할 수 있다.     
하지만 코루틴을 사용할 때에도 주의해야 할 점이 몇 가지 있다:

1. Update와 FixedUpdate의 역할: 'Update'와 'FixedUpdate'는 게임 루프의 일부로 렌더링, 물리, 상호작용 등을 처리하는 역할을 한다.     
코루틴은 주로 비동기 작업이나 지연 작업을 처리하는 데 사용되며, 이들 메서드의 역할과 목적을 대체할 수는 없다.
2. 코루틴 내부의 실행 시간: 코루틴 내에서 긴 시간 동안 실행되는 작업을 수행하면 이 역시 프레임 속도에 영향을 미칠 수 있다.      
따라서 코루틴 내에서도 오래 걸리는 작업을 작게 나누어 처리하거나, 비동기 처리 방식을 사용하는 것이 좋다.    
3. 언제 코루틴을 사용할 것인지: 코루틴은 주로 지연 작업이나 반복 작업을 처리하는 데 사용된다.   
그렇지만 게임 오브젝트의 상태 업데이트나 물리 계산 등과 같은 핵심적인 역할은 'Update'와 'FixedUpdate'에 맡겨야 한다.
4. 적절한 시점과 장면에서의 사용: 코루틴은 메인 스레드에서 실행되며, 복잡한 작업을 처리할 때 다른 스레드나 작업 큐를 고려해야 한다.     
또한 씬 간 전환 시에는 코루틴이 중단되기 때문에 이에 유의해야 한다.

요약하면, 'Update'와 'FixedUpdate'를 코루틴으로 대체하여 프레임 속도에 덜 민감한 비동기 작업이나 반복 작업을 처리할 수 있지만, 메서드의 목적과 게임 루프 역할을 대체할 순 없으며, 코루틴 내에서도 적절한 처리와 성능에 유의해야 한다.

# 17. 절차적 애니메이션
유니티의 절차적 애니메이션(Procedural Animation)은 미리 만들어진 애니메이션 클립이나 키프레임을 사용하지 않고, 코드 또는 수학적 알고리즘을 통해 캐릭터나 객체의 동작을 생성하는 기술이다.   
이를 통해 물리 시뮬레이션, 수학 함수, 알고리즘 등을 활용하여 더 자연스러운 동작을 만들거나 특별한 동작을 구현할 수 있다.

절차적 애니메이션의 주요 특징은 다음과 같다:

1. 유연성과 다양성: 절차적 애니메이션은 미리 만들어진 애니메이션 클립의 제약을 벗어나 동작을 생성하므로, 다양한 상황과 환경에 대응하는 더 다양한 동작을 만들 수 있다.
2. 실시간 반응성: 절차적 애니메이션은 실시간으로 동작을 생성하기 때문에 환경이나 상황에 따라 빠르게 반응할 수 있다.
3. 자연스러운 동작: 물리 시뮬레이션, 수학 함수, 알고리즘을 사용하여 보다 자연스럽고 현실적인 동작을 생성할 수 있다.
4. 변화와 조정: 절차적 애니메이션은 동작의 세부 사항이나 인자를 조정하거나 변경할 수 있어 다양한 스타일의 애니메이션을 만들 수 있다.
5. 복잡한 동작 구현: 절차적 애니메이션은 복잡한 동작을 구현할 때 유용하며, 사람의 행동, 동물의 움직임, 물리 시뮬레이션 등을 구현할 수 있다.

일반적으로 절차적 애니메이션은 물리 시뮬레이션을 활용하여 효과적으로 적용된다.      
예를 들어, 캐릭터의 걸음 걷기, 뛰기, 넘어지기, 점프 등의 동작을 물리 엔진을 사용하여 자연스럽게 구현할 수 있다.     
이 외에도 간단한 스크립트에서부터 복잡한 알고리즘을 활용한 동작 구현까지 다양한 상황에서 활용된다.

### 구현 방법
유니티에서 절차적 애니메이션을 만들기 위해서는 물리 시뮬레이션, 수학 함수, 알고리즘 등을 활용하여 움직임을 생성하고 제어하는 방법을 사용한다.   
아래는 절차적 애니메이션을 구현하기 위한 몇 가지 기본적인 방법이다:

1. 물리 시뮬레이션 활용: 유니티의 물리 엔진을 사용하여 캐릭터나 물체의 움직임을 자연스럽게 시뮬레이션할 수 있다.    
Rigidbody 컴포넌트를 적용하고 힘, 속도, 중력 등을 조절하여 다양한 동작을 생성한다.      
Rigidbody의 충돌 처리와 관절 제한을 사용하여 물리 시뮬레이션을 제어할 수도 있다.
2. Inverse Kinematics(IK): 캐릭터의 뼈대 구조를 기반으로 IK 알고리즘을 사용하여 원하는 위치나 방향으로 캐릭터의 관절을 움직일 수 있다.      
캐릭터의 손이나 발을 원하는 지점에 정확하게 위치시키거나, 지형과의 상호작용을 구현하는 데 사용된다.
3. 알고리즘과 수학 함수: 캐릭터의 움직임을 수학적 알고리즘과 함수를 사용하여 생성할 수 있다.    
예를 들어 사인 함수를 이용하여 물결 모양의 움직임을 만들거나, 벡터와 행렬 연산을 사용하여 복잡한 동작을 구현할 수 있다.
4. 커스텀 스크립트와 애니메이션 컨트롤러: 캐릭터의 상태, 환경 등을 고려하여 직접 스크립트를 작성하여 동작을 생성하고 제어할 수 있다.    
애니메이션 컨트롤러를 활용하여 다양한 상태와 전환을 관리하며, 스크립트에서 애니메이션 파라미터를 조절하여 절차적 동작을 생성한다.
5. 커스텀 쉐이더와 변형: 쉐이더를 사용하여 오브젝트의 외형을 변형하거나 특정한 움직임을 생성할 수 있다.     
GPU 기반의 연산을 사용하여 다이나믹한 효과와 움직임을 만들 수 있다.

절차적 애니메이션을 구현할 때는 해당 동작의 목적과 원하는 효과에 맞게 적절한 기술을 선택하고 적용해야 합니다.   
복잡한 애니메이션을 구현할 경우, 코드의 유지보수와 성능을 고려하여 적절한 디자인을 신중히 선택하는 것이 중요하다.

# 18. 오브젝트 풀링
유니티의 객체 풀링(Object Pooling)은 게임에서 빈번하게 생성되고 삭제되는 게임 오브젝트들을 효율적으로 관리하기 위한 기술이다.   
오브젝트 풀링은 오브젝트를 미리 생성하고 활성화/비활성화하여 재사용함으로써 게임의 성능을 향상시키고 메모리 사용량을 줄이는데 도움이 된다.

일반적으로 게임에서 총알, 파티클, 적 캐릭터 등이 빈번하게 생성되고 삭제되는데, 이러한 작업은 매번 오브젝트를 생성하고 삭제하는 것은 비용이 많이 들어 성능에 영향을 줄 수 있다.      
이를 해결하기 위해 객체 풀링을 사용한다.

오브젝트 풀링의 기본 아이디어는 다음과 같다:

1. 풀 생성: 게임 시작 시, 필요한 오브젝트들을 미리 생성하여 풀에 저장한다.  
이때 생성할 오브젝트의 개수는 예상되는 최대 동시 사용량을 기준으로 결정한다.
2. 오브젝트 재활용: 오브젝트를 필요할 때마다 풀에서 꺼내서 활성화하고 사용한다.     
사용 후에는 비활성화하여 풀로 다시 반환한다.
3. 비활성화된 상태 유지: 오브젝트를 풀에 반환하면 해당 오브젝트는 초기 상태로 초기화하고 비활성화된 상태로 유지된다.

유니티에서 오브젝트 풀링을 구현하려면 다음과 같은 단계를 따른다:

1. 풀링을 관리할 스크립트를 생성한다.   
2. 필요한 오브젝트들을 미리 생성하여 리스트나 큐 등에 저장한다.
3. 오브젝트를 필요한 위치에서 활성화하고 사용하며, 사용이 끝난 후에는 비활성화하여 풀로 반환한다.

오브젝트 풀링을 통해 오브젝트 생성 및 삭제 작업을 효율적으로 처리함으로써 게임의 성능과 메모리 사용량을 최적화할 수 있다.

# 19. 닷트윈
유니티의 DOTween은 게임 오브젝트의 애니메이션을 쉽게 제어하고 관리하기 위한 라이브러리이다.  
"DOTwenn"은 "DoTween"의 약자로, "Do Something with Tweening"의 줄임말이다.  
Tweening은 시간에 따른 값을 보간하여 애니메이션 효과를 만드는 기술을 말한다.

DOTween은 다음과 같은 주요 기능과 특징을 가지고 있다:

1. 간편한 애니메이션 제어: DOTween을 사용하면 코드 몇 줄로 간단한 애니메이션을 만들고 제어할 수 있다.   
위치, 회전, 크기, 색상 등의 속성을 대상으로 애니메이션을 쉽게 생성할 수 있다.
2. 이징(Easing) 함수 제공: DOTween은 다양한 이징 함수를 제공하여 애니메이션의 시작과 끝에서 속도를 조절할 수 있다.      
이로 인해 애니메이션이 자연스럽게 움직이는 효과를 만들 수 있다.
3. 시퀀스 및 그룹 애니메이션: 여러 개의 애니메이션을 연결하여 순차적으로 실행하거나 동시에 실행하는 시퀀스 및 그룹 애니메이션을 구성할 수 있다.
4. 애니메이션 루프 및 반복: 애니메이션을 지정한 횟수만큼 반복하거나 루프를 만들 수 있다.
5. 코루틴과 트윈: DOTween은 코루틴을 사용하지 않고도 비동기적으로 애니메이션을 다룰 수 있도록 도와준다.     
애니메이션 트윈을 사용하여 지연 시간과 간격을 다룰 수 있다.
6. 유니티 API 통합: DOTween은 유니티 내장 컴포넌트 및 기능과 통합되어 사용할 수 있다.   
예를 들어, DOTween을 사용하여 오브젝트의 트랜스폼 애니메이션을 쉽게 만들 수 있다.

DOTween은 에셋 스토어에서 다운로드하여 프로젝트에 추가하여 사용할 수 있다.  
이를 사용하면 코드를 작성하여 복잡한 애니메이션을 간단하게 만들고 제어할 수 있으며, 게임 개발의 효율성과 품질을 높일 수 있다.

</details>